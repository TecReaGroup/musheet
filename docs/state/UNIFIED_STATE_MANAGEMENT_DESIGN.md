# MuSheet 统一状态管理架构设计

> 版本 1.0 | 2026-01-16

## 文档概述

本文档详细描述 MuSheet 应用的统一状态管理架构设计。该架构基于 Flutter Riverpod 框架，旨在解决当前代码中存在的状态分散、重复定义、职责不清等问题，建立一套清晰、可维护、高性能的状态管理体系。

---

## 第一章：背景与动机

### 1.1 当前存在的问题

经过对现有代码的分析，发现以下核心问题：

**问题一：Provider 定义分散**

当前项目中，许多 Provider 被定义在 Screen 文件内部，而非集中在 providers 目录。这导致了几个后果：首先，难以发现和复用已有的状态管理逻辑；其次，当多个页面需要共享状态时，不得不通过 import Screen 文件的方式获取 Provider，造成不必要的耦合；最后，代码的可维护性下降，因为状态逻辑散落在各处。

**问题二：Library 与 Team 数据域重复实现**

应用需要同时支持个人音乐库（Library）和团队共享库（Team）两种数据域。当前的实现为这两种场景创建了独立的 Provider，导致大量重复代码。例如，乐谱排序逻辑在 Library 和 Team 场景中各实现一次，曲单管理逻辑同样如此。这不仅增加了维护成本，也容易造成两边行为不一致。

**问题三：状态刷新导致界面闪烁**

当前的刷新机制在重新加载数据时，会先将状态设为"加载中"，这会导致已有数据被清空。在列表页面表现为短暂的空白或加载指示器闪烁，用户体验不佳。

**问题四：计算逻辑在 UI 层重复执行**

过滤、排序等计算逻辑直接写在 Widget 的 build 方法中，每次界面重建都会重新计算，既浪费性能，也使 UI 代码变得臃肿难读。

**问题五：UI 状态与数据状态混杂**

搜索关键词、排序方式、Modal 可见性等 UI 交互状态，与乐谱、曲单等领域数据状态混在一起管理，职责边界模糊。

### 1.2 设计目标

基于上述问题，新架构需要实现以下目标：

- **单一事实源**：每种数据只有一个权威来源，避免状态不一致
- **状态分层**：数据状态、UI 状态、派生状态各司其职，边界清晰
- **数据域统一**：通过 DataScope 抽象，用同一套代码处理 Library 和 Team 数据
- **刷新不闪烁**：刷新时保留旧数据展示，新数据就绪后无缝替换
- **计算结果缓存**：过滤、排序等派生计算只在输入变化时重新执行
- **Screen 瘦身**：页面只负责渲染和事件分发，不包含业务逻辑

---

## 第二章：架构总体设计

### 2.1 分层架构

整体架构分为六个层次，从上到下依次为：

**第一层：UI 展示层（Screens）**

这是用户直接看到和交互的层面。Screen 组件只做三件事：订阅状态、渲染界面、分发用户意图。它不包含任何业务逻辑，也不定义任何 Provider。我们将这种设计称为"Dumb Screen"模式——页面足够"笨"，只是状态的忠实反映者。

**第二层：派生状态层（Derived State）**

这一层负责组合和计算。它从数据状态层和 UI 状态层读取原始数据，执行过滤、排序、搜索匹配等计算，输出可直接渲染的结果。派生状态是只读的，它不存储独立数据，只是对其他状态的加工。Riverpod 会自动缓存计算结果，只有当输入变化时才重新计算。

**第三层：UI 状态层**

管理所有与界面交互相关的临时状态，包括：搜索框中的查询文本、当前选择的排序方式、Modal 对话框的开关状态、当前激活的 Tab 页签等。这些状态通常不需要持久化（除了少数用户偏好设置），生命周期与用户会话一致。

**第四层：数据状态层**

管理应用的核心领域数据：乐谱列表、曲单列表、团队信息、用户认证状态、同步状态等。这些数据来自本地数据库或远程服务器，需要持久化存储。数据状态层提供标准的 CRUD 操作接口。

**第五层：仓库层（Repository）**

作为数据操作的抽象层，仓库封装了具体的数据存取逻辑。它协调本地数据源和远程数据源，处理离线优先策略，管理数据的序列化与反序列化。上层代码只与仓库接口交互，不关心数据的具体存储位置。

**第六层：数据源层（Data Source）**

最底层是具体的数据存储实现。本地数据源基于 Drift 数据库，负责持久化存储；远程数据源通过 API 客户端与服务器通信。数据源层只提供原始的读写操作，不包含业务逻辑。

### 2.2 数据流向

架构遵循严格的单向数据流原则：

用户在界面上的操作（如点击删除按钮）产生一个"意图"。这个意图被分发给对应的状态管理器（Notifier）。Notifier 执行相应的业务逻辑，更新内部状态。状态变化触发订阅者重新构建界面。用户看到更新后的结果。

整个流程中，UI 层只能读取状态，不能直接修改；状态的变更只发生在 Notifier 内部，确保变化可追踪、可预测。

### 2.3 依赖关系

层与层之间的依赖是单向的：上层可以依赖下层，下层不能依赖上层。

Screen 依赖派生状态层和 UI 状态层。派生状态层依赖数据状态层和 UI 状态层。数据状态层依赖仓库层。仓库层依赖数据源层。

这种依赖方向确保了系统的可测试性和模块化。

---

## 第三章：DataScope 统一数据域

### 3.1 设计理念

MuSheet 的核心功能需要同时支持两种数据域：用户个人的音乐库（Library）和团队共享的音乐库（Team）。这两种场景在数据结构、操作方式上高度相似，唯一的区别是数据的归属和同步策略不同。

为避免重复实现，我们引入 DataScope 作为统一的数据域标识。DataScope 是一个不可变的值对象，包含两个属性：类型（user 或 team）和标识符（用户为 0，团队为团队 ID）。

### 3.2 DataScope 的应用

通过 DataScope，同一个 Provider 可以服务于不同的数据域：

当页面展示个人乐谱时，使用用户域的 DataScope；当页面展示团队乐谱时，使用对应团队域的 DataScope。Provider 内部根据 DataScope 选择正确的数据源和同步协调器，外部调用方式完全一致。

这种设计带来的好处是：代码复用率大幅提升；新增团队时无需添加新的 Provider；Library 和 Team 的行为保证一致；测试时可以方便地切换数据域。

### 3.3 DataScope 的传递

DataScope 在应用中的传递遵循以下规则：

页面级别由路由参数决定——进入个人库页面时使用用户域，进入团队页面时从路由获取团队 ID 构建团队域。

在页面内部，DataScope 通过 Provider 的 family 参数向下传递，而非通过 Widget 参数层层传递。这样可以避免"参数穿透"问题，任何需要数据的子组件都可以直接从 Provider 获取。

---

## 第四章：数据状态层详细设计

### 4.1 核心数据 Provider

数据状态层包含以下核心 Provider：

**乐谱数据 Provider**

管理乐谱列表的加载、增删改查。支持按 DataScope 区分个人和团队乐谱。监听认证状态变化，用户登出时清空数据；监听同步完成事件，同步成功后刷新列表。

**曲单数据 Provider**

管理曲单列表，设计模式与乐谱 Provider 一致。曲单与乐谱的关联关系也在此管理。

**团队数据 Provider**

管理用户加入的团队列表。由于团队本身不区分 DataScope（团队列表属于用户全局数据），使用普通 Provider 而非 family Provider。

**认证状态 Provider**

管理用户的登录状态、会话信息、用户资料。提供登录、登出、刷新会话等操作。其他 Provider 监听认证状态的变化来做出相应调整。

**同步状态 Provider**

暴露同步协调器的当前状态，包括同步阶段、待同步变更数量、最后同步时间等。区分用户域同步和各团队域同步。

**网络状态 Provider**

暴露设备的网络连接状态。数据 Provider 根据网络状态决定是否尝试远程操作。

### 4.2 数据加载策略

数据 Provider 遵循以下加载策略：

**初始加载**：Provider 首次被访问时，从本地数据库加载数据。这确保了离线时应用仍能正常使用。

**后台刷新**：如果网络可用，在本地数据加载完成后，触发后台同步。同步完成后刷新列表。

**手动刷新**：用户下拉刷新时，触发即时同步操作。

**事件驱动刷新**：认证状态变化、同步完成等事件会触发相关 Provider 重新加载。

### 4.3 状态更新机制

当执行 CRUD 操作时，采用"乐观更新"策略：

执行添加操作时，先将新数据追加到当前列表，立即更新界面，然后异步写入数据库并触发同步。

执行删除操作时，先从列表移除目标项，更新界面，再异步删除数据库记录。

执行修改操作时，先用新数据替换列表中的旧记录，更新界面，再异步持久化。

这种策略确保了界面响应的即时性，同时通过异步操作保证数据最终一致。

### 4.4 刷新不闪烁设计

为解决刷新时界面闪烁的问题，采用"保留旧值刷新"模式：

刷新开始时，不清空当前数据，而是标记为"正在刷新"状态。界面可以继续展示旧数据，同时显示一个轻量的刷新指示器（如顶部进度条）。

新数据加载完成后，用新列表替换旧列表。由于数据替换是原子操作，界面会平滑过渡，不会出现空白。

如果刷新失败，保留旧数据不变，仅提示错误信息。用户仍然可以查看和操作已有数据。

---

## 第五章：UI 状态层详细设计

### 5.1 UI 状态分类

UI 状态按其性质分为以下几类：

**交互状态**

用户当前的操作上下文，生命周期短，不需要持久化。包括：搜索框中正在输入的文字、Modal 对话框的打开/关闭状态、列表的滚动位置、选中的项目等。

**视图配置状态**

用户对界面展示方式的选择，可能需要持久化。包括：当前选择的排序方式、列表显示模式（网格/列表）、当前激活的 Tab 页签等。

**用户偏好状态**

跨会话保持的用户设置，必须持久化。包括：偏好的乐器类型、是否启用深色模式、默认节拍器速度等。

**最近记录状态**

需要持久化的使用历史。包括：最近打开的乐谱记录（用于"最近打开"排序）、最后查看的页面位置、最后使用的设置等。

### 5.2 统一出口原则

所有 UI 状态 Provider 必须定义在统一的位置，禁止在 Screen 文件中定义。这个统一出口确保了：

状态定义的集中管理，便于查找和维护。

状态命名的一致性，通过统一规范避免混乱。

状态复用的便利性，任何页面都可以直接引用公共状态。

### 5.3 Scoped UI 状态设计

对于需要按数据域区分的 UI 状态（如排序、搜索），采用与数据 Provider 相同的 DataScope 机制：

排序状态需要区分"个人乐谱的排序"和"团队乐谱的排序"，使用 DataScope 加实体类型（scores/setlists）作为复合键。

搜索状态可能需要区分不同页面的搜索上下文，使用 DataScope 加功能区域（home/library）作为复合键。

最近打开记录需要区分个人和团队的打开历史，同样使用 DataScope 区分。

### 5.4 持久化策略

需要持久化的 UI 状态采用以下策略：

Provider 初始化时，异步从 SharedPreferences 读取存储的值。在值加载完成前，使用合理的默认值。

状态更新时，同步更新内存中的值，异步写入存储。写入操作可以适当防抖，避免频繁 IO。

存储键命名包含 DataScope 信息，确保不同数据域的状态互不干扰。

---

## 第六章：派生状态层详细设计

### 6.1 派生状态的本质

派生状态不是独立存储的数据，而是从其他状态计算得来的结果。它的核心特征是：

**纯函数性**：相同的输入始终产生相同的输出，没有副作用。

**声明式依赖**：显式声明依赖哪些源状态，框架自动追踪依赖关系。

**自动缓存**：计算结果被缓存，只有依赖变化时才重新计算。

**只读性**：派生状态只能被读取，不能被直接修改。

### 6.2 常见派生模式

**过滤模式**

输入：原始列表 + 过滤条件
输出：符合条件的子列表
应用：搜索结果、按状态筛选、按类型筛选

**排序模式**

输入：原始列表 + 排序配置
输出：排序后的列表
应用：按名称排序、按日期排序、按最近打开排序

**组合模式**

输入：多个数据源
输出：组合后的复合对象
应用：页面 ViewModel、统计汇总数据

**转换模式**

输入：原始数据
输出：转换后的展示数据
应用：日期格式化、数值单位转换、状态文本映射

### 6.3 派生链设计

派生状态可以链式组合，形成计算管道：

原始乐谱列表 → 过滤（按搜索词）→ 排序（按用户选择）→ 分页（取前 N 条）→ 最终展示列表

每一步都是独立的派生 Provider，各自缓存中间结果。当搜索词变化时，只有过滤步骤及其后续需要重新计算；当排序方式变化时，过滤结果可以复用。

这种设计最大化了计算复用，最小化了不必要的重算。

### 6.4 ViewModel 模式

对于复杂页面，推荐使用 ViewModel 模式将多个状态聚合为一个派生对象：

Home 页面的 ViewModel 聚合了：最近打开的乐谱、最近打开的曲单、搜索结果、搜索状态等。页面只需订阅一个 ViewModel Provider，就能获得渲染所需的全部数据。

ViewModel 的好处是：减少 Widget 中的状态订阅数量；将数据组装逻辑从 UI 层移到 Provider 层；便于单元测试数据组装逻辑。

---

## 第七章：Screen 设计规范

### 7.1 Dumb Screen 原则

Screen 组件应该足够"笨"，它的职责严格限定为：

**订阅状态**：通过 watch 方法监听需要的 Provider。

**渲染界面**：根据当前状态构建 Widget 树。

**分发意图**：将用户操作转化为对 Notifier 方法的调用。

Screen 不应该包含：Provider 定义、业务逻辑计算、直接的数据操作。

### 7.2 状态订阅策略

订阅时应尽量精确，只订阅实际需要的数据：

如果只需要知道列表是否为空，可以使用 select 只订阅长度属性，而非整个列表。

如果只需要某个布尔标志，直接订阅该标志的 Provider，而非包含该标志的大对象。

精确订阅可以避免不必要的 Widget 重建，提升性能。

### 7.3 意图分发模式

用户操作的处理遵循固定模式：

事件回调中，使用 read（而非 watch）获取 Notifier，调用其方法。Notifier 方法执行业务逻辑，更新状态。状态更新触发 Widget 重建。

这确保了状态变更的可追踪性——所有变更都经过 Notifier，可以在 Notifier 中统一添加日志、验证等逻辑。

### 7.4 禁止事项

以下做法在 Screen 中被禁止：

**禁止定义 Provider**：所有 Provider 必须在 providers 目录下的文件中定义。

**禁止从其他 Screen 导入**：如果需要共享状态，该状态应该定义在公共的 Provider 文件中。

**禁止在 build 中进行复杂计算**：过滤、排序等逻辑应该移到派生 Provider 中。

**禁止直接操作数据库或 API**：数据操作必须通过 Repository 进行。

---

## 第八章：同步与事件响应

### 8.1 同步触发机制

数据同步在以下情况触发：

**应用启动**：如果用户已登录且网络可用，在后台启动同步。

**用户登录**：登录成功后立即触发全量同步。

**网络恢复**：从离线恢复到在线时，触发同步。

**手动刷新**：用户主动下拉刷新时触发。

**本地数据变更**：本地增删改操作后，触发增量上传。

### 8.2 同步完成响应

同步完成后，相关的数据 Provider 需要刷新以反映最新数据：

Provider 通过监听同步状态，当检测到同步从"进行中"变为"完成"时，触发自身刷新。

刷新采用前述的"保留旧值"策略，确保用户体验流畅。

### 8.3 认证状态响应

认证状态变化对各层有不同影响：

**用户登录**：数据 Provider 开始加载用户数据；同步服务开始工作；UI 状态可能需要恢复用户上次的偏好。

**用户登出**：数据 Provider 清空当前数据；同步服务停止；部分 UI 状态重置为默认值。

**会话过期**：与登出类似，但可能需要提示用户重新登录。

### 8.4 网络状态响应

网络状态变化影响数据操作策略：

**在线时**：优先使用远程数据；增删改操作实时同步。

**离线时**：完全使用本地数据；增删改操作保存到本地，等待后续同步。

**从离线到在线**：触发同步，上传积压的本地变更，下载远程更新。

---

## 第九章：Provider 组织规范

### 9.1 文件结构

Provider 按职责分类放置在不同文件中：

**core_providers.dart**：核心基础设施 Provider，包括网络服务、会话服务、数据库实例、API 客户端等。

**auth_state_provider.dart**：认证相关的状态管理。

**scores_state_provider.dart**：乐谱数据的状态管理。

**setlists_state_provider.dart**：曲单数据的状态管理。

**teams_state_provider.dart**：团队数据的状态管理。

**ui_state_providers.dart**：所有 UI 状态的统一定义。

**derived/** 目录：派生状态 Provider，可按页面或功能细分文件。

### 9.2 命名规范

Provider 命名遵循以下规则：

**数据 Provider**：{scope}{Entity}Provider 或 scoped{Entity}Provider
示例：scopedScoresProvider, teamsStateProvider

**UI 状态 Provider**：{feature}{State}Provider 或 scoped{Feature}Provider
示例：searchQueryProvider, scopedSortProvider

**派生 Provider**：{computed}{Entity}Provider 或 {feature}ViewModelProvider
示例：filteredScoresProvider, homeViewModelProvider

**服务 Provider**：{service}Provider
示例：networkServiceProvider, sessionServiceProvider

### 9.3 依赖管理

Provider 之间的依赖应保持单向和清晰：

派生 Provider 可以依赖数据 Provider 和 UI 状态 Provider。

数据 Provider 可以监听认证、同步状态 Provider。

UI 状态 Provider 通常不依赖其他 Provider（除非需要从持久化存储恢复）。

避免循环依赖，如果出现循环依赖通常意味着设计需要调整。

---

## 第十章：性能优化策略

### 10.1 减少不必要的重建

**使用 select**：当只需要对象的部分属性时，使用 select 提取，避免因无关属性变化导致重建。

**拆分 Provider**：将大的状态对象拆分为多个小的 Provider，让组件只订阅需要的部分。

**合理使用 family**：对于需要参数的 Provider，使用 family 而非在 Provider 内部管理多个实例。

### 10.2 延迟初始化

非立即需要的 Provider 应该延迟到首次使用时才初始化：

团队相关的 Provider 可以在用户进入团队页面时才加载。

重量级的派生计算可以使用 autoDispose 在不再使用时释放。

### 10.3 缓存策略

派生 Provider 的缓存由 Riverpod 自动管理，但需要注意：

确保派生函数是纯函数，相同输入产生相同输出。

避免在派生函数中产生副作用。

对于昂贵的计算，考虑输入的稳定性，避免因频繁的微小变化触发重算。

### 10.4 列表优化

大列表的处理需要特别注意：

使用虚拟列表（ListView.builder）而非一次性构建所有项。

对列表项使用稳定的 key，帮助 Flutter 正确识别变化。

考虑分页加载，避免一次加载过多数据。

---

## 第十一章：测试策略

### 11.1 单元测试

**Notifier 测试**：测试状态变更逻辑是否正确。模拟依赖的 Repository，验证方法调用和状态更新。

**派生 Provider 测试**：测试计算逻辑是否正确。提供不同的输入组合，验证输出符合预期。

### 11.2 集成测试

测试 Provider 之间的交互：认证状态变化后数据 Provider 的行为、同步完成后列表的刷新、网络状态变化的处理等。

### 11.3 Widget 测试

使用 ProviderScope 包装被测 Widget，注入模拟的 Provider 状态，验证 UI 渲染和交互行为。

---

## 第十二章：总结

本架构设计围绕"单一事实源、状态分层、数据域统一"三个核心理念，构建了清晰的状态管理体系：

**分层架构**确保了职责分离，每一层专注于自己的工作。

**DataScope 机制**消除了 Library/Team 的代码重复，提供了一致的编程模型。

**派生状态层**将计算逻辑从 UI 层剥离，提升了性能和可维护性。

**Dumb Screen 模式**简化了页面代码，使其专注于展示和交互。

**统一的 Provider 组织**使代码结构清晰，易于导航和维护。

遵循本设计进行实现，可以有效解决当前代码中的状态管理问题，为 MuSheet 应用奠定坚实的技术基础。

---

## 附录：术语表

| 术语 | 定义 |
|------|------|
| DataScope | 数据域标识，区分个人库和团队库 |
| Dumb Screen | 只负责渲染和事件分发的轻量页面 |
| 派生状态 | 从其他状态计算得来的只读状态 |
| Notifier | Riverpod 中管理可变状态的类 |
| Provider | Riverpod 中暴露状态的声明 |
| 单一事实源 | 每种数据只有一个权威来源的设计原则 |
| 乐观更新 | 先更新 UI 后持久化的策略 |
| 保留旧值刷新 | 刷新时不清空已有数据的策略 |
