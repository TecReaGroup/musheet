# MuSheet 离线优先同步策略

**开发蓝图 v2.0**

---

## 核心架构原则

1. **UI 的唯一真理是本地数据库**：UI 永远不等待网络，只读写本地 Drift (SQLite)。用户的每一次操作都应该立刻得到响应，不存在"正在加载"的等待状态。

2. **网络只是搬运工**：后台的 SyncServiceV2 负责把本地和云端的数据差异抹平。用户完全不需要关心"同步"这件事，一切都在后台静默完成。

3. **按需策略**：根据数据类型采用完全不同的同步频率和方式——乐谱元数据需要快速同步，PDF 文件则懒加载，标注则按打开的 PDF 范围拉取。

4. **上传优先原则**：本地的所有修改（包括删除）必须先推送到服务器，确认成功后才能拉取服务器数据。这保证用户意图不会被服务器数据覆盖。

---

## MuSheet 数据模型概览

在深入同步策略前，先理解 MuSheet 的数据结构：

- **Score（乐谱）**：一首曲子的基本信息，如《月光奏鸣曲》。包含标题、作曲家、BPM。
- **InstrumentScore（乐器分谱）**：一首曲子的某个乐器版本，如《月光奏鸣曲 - 小提琴谱》。每个分谱关联一个 PDF 文件。一首 Score 可以有多个 InstrumentScore。
- **Annotation（标注）**：用户在某个 InstrumentScore 的 PDF 上画的笔记，如划线、圈注、文字标注。
- **Setlist（曲单）**：用户创建的演出曲目列表，如"周六晚演出"。
- **SetlistScore（曲单曲目）**：Setlist 和 Score 的关联关系，包含排序。

---

## 第一部分：下载策略 (Pull Strategy)

我们将下载分为三类场景，处理方式完全不同。

### 1. 乐谱元数据同步 (Score & Setlist Metadata)

**场景：** 用户打开 App，看到曲库列表和曲单列表。

**策略：** **"静默增量更新 (Silent Incremental Update)"**

1. **即时渲染：** App 启动，立刻读取本地 Drift 数据库，展示上次缓存的曲库和曲单。用户看到的永远是"有东西"的状态，不是空白页。

2. **后台询问：** SyncServiceV2 向 Serverpod 后端发起请求："我上次同步是在 `lastSyncAt`，之后有什么变化吗？"

3. **增量拉取：**
   - **无变化：** 后端返回空列表。结束，不做任何事。
   - **有变化：** 后端仅返回增量数据——新增的 Score、修改过的 Setlist、被删除的记录（通过 deletedAt 标识）。

4. **合并写入：** 同步服务将变更合并到本地数据库。对于每条记录：
   - 比较 version，如果服务器版本更高则覆盖本地
   - 更新 serverId（如果本地是新建的记录）
   - 标记 syncStatus = synced

5. **UI 响应：** 通过 Riverpod 的 AsyncNotifier，数据库变动自动触发 UI 刷新。用户会看到列表突然多了一首曲子——但这一切是静默的，没有任何"正在同步"的提示。

### 2. 标注同步 (Annotation Sync)

**场景：** 用户点击打开了某个 InstrumentScore 的 PDF，需要看到这个 PDF 上的标注。

**策略：** **"按 PDF 范围拉取 (Scoped Fetch by InstrumentScore)"**

*关键点：不要在打开 App 时拉取所有 PDF 的标注，只拉取当前打开的这个 InstrumentScore 的标注。这能节省大量流量。*

1. **加载本地：** 打开 PDF 时，立刻渲染本地已有的 Annotation。用户看到的是上次的笔记状态。

2. **触发同步：** 进入 ScoreViewerScreen 后，后台发起请求："给我 instrumentScoreId 为 `xxx` 的所有标注更新。"

3. **合并策略：** 后端返回一组 Annotation 数据。由于标注的冲突粒度是单个笔画（每个 Annotation 有独立 UUID），合并逻辑相对简单——本地没有的就新增，本地有的比较 updatedAt。

4. **静默刷新：** 写入本地库，屏幕上的标注自动刷新。用户可能会看到某个笔记"突然出现"（队友加的），但不会有弹窗打断他。

### 3. PDF 文件下载 (PDF Asset Download)

**场景：** 用户点击了一个 InstrumentScore，但本地还没有对应的 PDF 文件，或者云端有更新版本。

**策略：** **"懒加载 + 缓存优先 + Hash 校验 (Lazy Load & Cache-First)"**

1. **检查本地缓存：** 检查 pdfPath 指向的文件是否存在，以及 pdfSyncStatus 是否为 synced。

2. **Hash 校验：** 如果本地有文件，比较 pdfHash 和服务器记录的 Hash。如果相同，直接使用本地文件，零网络请求。

3. **状态分支：**
   - **有缓存且 Hash 一致：** 直接打开本地 PDF。
   - **无缓存或 Hash 不一致：** 显示下载进度 → 流式下载写入本地 → 计算并存储 pdfHash → 标记 pdfSyncStatus = synced → 打开。

4. **后台预加载：** 在 WiFi 环境下，可以预先下载用户曲库中还没有本地缓存的 PDF，但这是低优先级任务。但是如果打开的 InstrumentScore pdf 本地无缓存或者hash不一致则显示加载动画，等待下载pdf，此时pdf优先级较高。

---

## 第二部分：上传策略 (Push Strategy)

### 🔴 关键原则：严格的上传优先队列

**所有本地修改必须先上传到服务器，上传队列完全清空后才能处理下载请求。**

```
同步流程严格顺序：
┌─────────────────────────────────────────────────────────────┐
│  STEP 1: UPLOAD QUEUE (上传队列)                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  优先级 1: 删除操作 (Delete)      ← 最高优先级            │ │
│  │  优先级 2: 创建操作 (Create)                              │ │
│  │  优先级 3: 更新操作 (Update)                              │ │
│  └─────────────────────────────────────────────────────────┘ │
│                           ↓                                  │
│              [等待上传队列完全清空]                            │
│                           ↓                                  │
│  STEP 2: DOWNLOAD QUEUE (下载队列)                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  - 增量数据拉取 (Incremental Pull)                        │ │
│  │  - PDF 文件下载 (File Download)                           │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

为什么上传必须优先？
- 如果先下载，服务器数据会覆盖用户本地修改
- 特别是删除操作：如果用户删除了某项，但下载先执行，
  服务器会把删除的项同步回来，导致删除失效
```

---

### 1. 删除操作同步 (Delete Sync) - 最高优先级 🔴

**场景：** 用户删除了一首乐谱、一个分谱、一个曲单、或一条标注。

**策略：** **"立即标记 + 优先上传 + 级联处理 (Immediate Mark & Priority Push & Cascade)"**

1. **用户操作：** 用户删除一个 Score。

2. **本地处理：**
   ```
   - 标记 Score.deletedAt = DateTime.now()
   - 标记 Score.syncStatus = pending_delete
   - 级联标记所有关联的 InstrumentScore.deletedAt
   - 级联标记所有关联的 Annotation.deletedAt
   - 级联标记所有关联的 SetlistScore.deletedAt
   ```

3. **UI 响应：**
   - 立刻从列表中移除该项（乐观 UI）
   - 被删除的记录不再显示，但仍保留在数据库中等待同步

4. **加入上传队列：**
   - 删除操作以**最高优先级**加入上传队列
   - 队列项格式：`{ type: 'delete', entityType: 'Score', entityId: xxx, deletedAt: xxx }`

5. **同步执行：**
   - 同步服务在 Push 阶段**优先处理删除操作**
   - 发送请求到服务器：`deleteScore(serverId, deletedAt)`
   - 服务器标记 `deletedAt`，并**级联删除**关联数据

6. **回调处理：**
   - **成功：**
     - 可以选择保留记录（软删除）或物理删除
     - 标记 syncStatus = synced
   - **失败：**
     - **保持 pending_delete 状态**
     - **重新放回上传队列等待重试**
     - 阻止下载队列执行，直到删除成功

7. **冲突处理：**
   - 如果服务器返回"记录已不存在"→ 视为成功
   - 如果服务器返回"记录已被修改"→ 使用 LWW 判断（见冲突解决章节）

---

### 2. 级联删除详细规则

当删除父实体时，必须处理所有关联的子实体：

| 删除的实体 | 级联影响 | 处理方式 |
|-----------|---------|---------|
| **Score** | InstrumentScores, Annotations, SetlistScores | 全部标记 deletedAt，分别加入删除队列 |
| **InstrumentScore** | Annotations (该分谱的), PDF 文件 | Annotations 标记删除，PDF 本地删除 |
| **Setlist** | SetlistScores | 关联记录标记删除 |
| **Annotation** | 无 | 仅删除自身 |

**级联删除同步流程：**

```
用户删除 Score "月光奏鸣曲"
         ↓
1. 标记 Score.deletedAt
         ↓
2. 查询所有关联的 InstrumentScore
   ├── "月光-钢琴谱" → 标记 deletedAt
   │   └── 其下所有 Annotation → 标记 deletedAt
   └── "月光-小提琴谱" → 标记 deletedAt
       └── 其下所有 Annotation → 标记 deletedAt
         ↓
3. 查询所有关联的 SetlistScore → 标记 deletedAt
         ↓
4. 所有标记的记录加入上传队列（删除类型）
         ↓
5. 同步到服务器（父实体优先，子实体跟随）
         ↓
6. 成功后，处理 PDF 文件清理
```

---

### 3. PDF 文件删除处理

**本地 PDF 删除规则：**

1. **立即删除：** 当 InstrumentScore 被删除且同步成功后，立即删除本地 PDF 文件
2. **路径：** `appDir/pdfs/{scoreId}_{instrumentScoreId}.pdf`

**服务器 PDF 删除规则：**

1. **软删除：** 服务器上的 PDF 文件不立即删除
2. **保留期：** 保留 30 天，以便用户后悔时可以恢复
3. **定时清理：** 服务器后台任务每日清理过期文件

```dart
// 删除流程伪代码
Future<void> handleInstrumentScoreDelete(String id) async {
  // 1. 标记数据库记录删除
  await db.instrumentScores.markDeleted(id);
  
  // 2. 同步到服务器
  final success = await syncService.pushDelete('InstrumentScore', id);
  
  // 3. 同步成功后删除本地 PDF
  if (success) {
    final pdfPath = await getPdfPath(id);
    if (await File(pdfPath).exists()) {
      await File(pdfPath).delete();
    }
  }
}
```

---

### 4. 乐谱元数据同步 (Score, InstrumentScore, Setlist)

**策略：** **"写入即忘 + 定时批量上传 (Fire-and-Forget & Periodic Batch)"**

1. **用户操作：** 创建一个新 Score，添加一个 InstrumentScore，或者修改 Setlist 名称等等。

2. **写入本地：** 立刻存入 Drift 数据库，标记 syncStatus = pending，version 递增。UI 通过 Riverpod 立刻更新，用户看到自己的修改。

3. **触发同步：** Provider 调用 SyncServiceV2.markModified() 标记有待同步的数据。同步服务会在合适的时机（定时器、App 切后台、网络恢复）执行上传。

4. **批量上传：** 同步服务收集所有 pending 状态的记录，打包发送到 Serverpod 后端。

5. **服务端处理：**
   - 如果是新记录（serverId 为空），服务器创建记录，返回 serverId
   - 如果是更新，服务器比较 version，接受或拒绝更新
   - 返回最新的 version

6. **回调处理：**
   - **成功：** 更新本地记录的 serverId 和 version，标记 syncStatus = synced
   - **版本冲突：** 标记 syncStatus = conflict，根据 LWW 策略自动解决或等待用户处理
   - **网络失败：** 保持 pending 状态，等待下一次触发

### 5. 标注同步 (Annotation - 高频数据)

**策略：** **"写入即忘 + 防抖批量上传 (Write-Ahead & Debounced Batch)"**

*标注是高频操作——用户画一笔可能只需要 0.1 秒，不可能每画一笔就发一次网络请求。*

1. **用户操作：** 在 PDF 上画一笔。

2. **写入本地：** 创建 Annotation 记录存入 Drift，UI 立刻渲染这一笔。用户感知是即时的。

3. **防抖 (Debounce)：** 设置 2-5 秒的防抖计时器。如果用户在这段时间内继续画，重置计时器。这样连续的操作会合并成一次网络请求。

4. **批量打包：** 计时器到期后，把过去这段时间内所有新增/修改的 Annotation 打包成一个请求。

5. **发送：** 调用 RPC 接口批量同步。

6. **回调处理：** 成功则标记为 synced，失败则保持 dirty 等待重试。

### 6. PDF 文件上传 (Large File Upload)

**策略：** **"任务队列 + Hash 去重 (Task Queue & Deduplication)"**

1. **用户操作：** 导入一个 PDF 作为新的 InstrumentScore。

2. **本地处理：**
   - 复制 PDF 文件到 App 私有目录（避免用户删除原文件导致丢失）
   - 计算文件 MD5 Hash
   - 创建 InstrumentScore 记录，pdfSyncStatus = pending

3. **后台上传：** SyncServiceV2 的文件同步阶段会处理所有 pdfSyncStatus = pending 的记录。

4. **Hash 去重：** 上传前先问服务器："有没有 Hash 为 xxx 的文件？"如果有，直接关联，跳过上传（秒传）。

5. **执行上传：** 在后台线程上传文件。**关键是不阻塞 UI**，用户可以继续浏览其他曲子。

6. **完成：** 更新 pdfSyncStatus = synced，存储服务器返回的文件 URL。

---

## 第三部分：触发机制 (Triggers)

同步不是"用户点击同步按钮"才发生的，而是由一系列自动触发器驱动的。

### 1. 定时触发 (Periodic Timer)

- **监听对象：** 5 分钟定时器
- **动作：** 触发完整同步流程（Push → Pull → File Sync）
- **目的：** 保证数据不会太旧，即使用户一直开着 App 也能定期与云端保持一致

### 2. 数据变更触发 (On Data Modified)

- **监听对象：** Provider 层调用 SyncServiceV2.markModified()
- **动作：** 将变更记录加入同步队列，触发延迟同步（防抖）
- **目的：** 用户修改尽快上云

### 3. 生命周期触发 (App Lifecycle)

- **监听对象：** App 从后台切回前台 (Resumed)
- **动作：** 触发 Pull 拉取最新数据
- **目的：** 用户可能在其他设备上做了修改，切回来应该看到最新的

### 4. 网络状态触发 (Connectivity)

- **监听对象：** 网络从断开变为连接
- **动作：**
  - 触发 Push 重试（把积压的本地修改发出去）
  - 触发 Pull（拉取可能遗漏的更新）
- **目的：** 自动灾难恢复。用户在地铁里断网操作了一堆，出站后自动同步

### 5. 场景进入触发 (Navigation Based)

- **监听对象：** 用户进入 ScoreViewerScreen（PDF 查看页）
- **动作：** 触发当前 InstrumentScore 的标注同步 + PDF 下载检查
- **目的：** 按需加载，节省流量

### 6. 手动触发 (User Action)
- **监听对象：** 用户点击"同步"按钮
- **动作：** 立即执行完整同步流程

---

## 第四部分：冲突解决策略 (Conflict Resolution)

对于 MuSheet 这类乐谱笔记应用，我们采用简单有效的策略，不搞复杂的合并算法。

### 基本原则：最后写入者胜 (Last Write Wins, LWW)

- **规则：** 每条记录都有 version 和 updatedAt/deletedAt 时间戳
- **判定：** 谁的操作时间戳更晚，谁的操作就被保留
- **服务器逻辑：** 接收到更新时，比较 version。如果客户端 version < 服务器 version，说明客户端数据过期，返回冲突状态让客户端重新拉取

### 冲突粒度

不同数据类型的冲突判定粒度不同：

- **Score / Setlist：** 冲突粒度是**整条记录**。用户 A 改了 BPM，用户 B 改了作曲家，这算冲突，取最后修改的整个版本。

- **InstrumentScore：** 冲突粒度是**整条记录**。

- **Annotation：** 冲突粒度是**单个标注（笔画）**。用户 A 在第 1 页画了一笔，用户 B 在第 2 页画了一笔，这不算冲突——两者都会被保留。只有两人修改了同一个 Annotation（相同 UUID）才算冲突。

### 🔴 删除冲突的正确处理（LWW 原则）

删除操作也遵循 LWW 原则，**不再无条件恢复数据**：

| 场景 | 判定规则 | 结果 |
|-----|---------|------|
| **本地删除 + 服务器修改** | 比较 `local.deletedAt` 和 `server.updatedAt` | 时间戳更晚者胜 |
| **服务器删除 + 本地修改** | 比较 `server.deletedAt` 和 `local.updatedAt` | 时间戳更晚者胜 |
| **双方都删除** | 都标记删除 | 删除 |

**详细逻辑：**

```
场景 1: 本地删除 + 服务器修改
─────────────────────────────
Timeline:
  T1: 用户 A 在设备 1 删除了 Score (deletedAt = T1)
  T2: 用户 B 在设备 2 修改了同一个 Score (updatedAt = T2)

判定:
  if (local.deletedAt > server.updatedAt) {
    // 删除操作更晚 → 删除胜
    sendDeleteToServer();
  } else {
    // 修改操作更晚 → 恢复数据
    restoreFromServer();
  }
```

```
场景 2: 服务器删除 + 本地修改
─────────────────────────────
Timeline:
  T1: 用户 A 在设备 1 删除了 Score (server.deletedAt = T1)
  T2: 用户 B 在设备 2 修改了同一个 Score (local.updatedAt = T2)

判定:
  if (local.updatedAt > server.deletedAt) {
    // 本地修改更晚 → 重新创建
    recreateOnServer();
  } else {
    // 服务器删除更晚 → 删除本地
    deleteLocal();
  }
```

**为什么这样设计？**

旧设计的问题：
- "本地删除 + 服务器修改 → 恢复数据" 会导致用户删除操作被撤销
- 如果用户明确要删除某项，结果同步后又出现了，用户体验很差

新设计的优势：
- 遵循 LWW 原则，时间戳更晚的操作总是胜出
- 用户意图得到尊重：如果用户最后的操作是删除，那就删除
- 逻辑一致：删除和修改使用相同的冲突解决规则

---

## 第五部分：同步状态机 (State Machine)

SyncServiceV2 内部是一个状态机，有明确的状态和转换规则。

### 状态定义

1. **空闲 (Idle)：** 没有同步任务在执行，等待触发。可以显示"已同步"或"X 分钟前同步"。
2. **同步中 (Syncing)：** 正在执行同步，有细分的阶段。可以显示同步进度。
3. **等待网络 (Waiting for Network)：** 同步时发现没网，暂停等待网络恢复。
4. **上传阻塞 (Upload Blocked)：** 有待上传操作失败，阻止下载执行。
5. **有冲突 (Conflicted)：** 发现无法自动解决的冲突，需要用户介入。
6. **错误 (Error)：** 发生错误，会自动重试。可以显示错误信息。
7. **已暂停 (Paused)：** 用户手动暂停了同步（如流量节省模式）。

### 🔴 同步阶段 (严格顺序执行)

```
┌────────────────────────────────────────────────────────────────┐
│                      完整同步流程                               │
├────────────────────────────────────────────────────────────────┤
│  1. 初始化 (Initializing)                                       │
│     └── 检查登录状态，准备同步上下文                              │
│                           ↓                                     │
│  2. 上传队列 (Upload Queue) ⭐ 必须全部完成                       │
│     ├── 2.1 删除操作 (Priority: Highest)                        │
│     │       └── 处理所有 pending_delete 状态的记录                │
│     ├── 2.2 创建/更新操作 (Priority: Normal)                     │
│     │       └── 处理所有 pending 状态的记录                       │
│     └── 2.3 文件上传 (PDF Upload)                               │
│             └── 处理所有 pdfSyncStatus = pending 的文件           │
│                           ↓                                     │
│              ┌─────────────────────────────────┐                 │
│              │   上传队列是否完全清空？          │                 │
│              │   (所有操作都成功)               │                 │
│              └─────────────────────────────────┘                 │
│                     ↓ Yes              ↓ No                      │
│                     │                  │                         │
│                     │          返回步骤 2，重试失败项             │
│                     │          或进入 Upload Blocked 状态         │
│                     ↓                                            │
│  3. 下载队列 (Download Queue) ⭐ 只有上传完成后才执行              │
│     ├── 3.1 增量数据拉取 (Incremental Pull)                      │
│     │       └── 获取 lastSyncAt 之后的服务器变更                  │
│     ├── 3.2 合并处理 (Merge)                                     │
│     │       └── 应用 LWW 规则处理冲突                             │
│     └── 3.3 文件下载 (PDF Download)                              │
│             └── 下载缺失或过期的 PDF 文件                         │
│                           ↓                                     │
│  4. 完成 (Finalizing)                                           │
│     └── 更新 lastSyncAt，清理状态，发送完成通知                   │
└────────────────────────────────────────────────────────────────┘
```

### 关键约束

1. **上传阻塞下载**：只要上传队列中有未完成的操作，就不会开始下载
2. **删除优先**：删除操作在上传队列中优先级最高
3. **失败重试**：上传失败的操作会重试，重试 3 次后进入 Error 状态
4. **断点续传**：如果同步中断（网络断开、App 被杀），下次会从上传队列继续

---

## 第六部分：操作队列 (Operation Queue)

为了保证离线操作的可靠性，所有待同步的操作都会进入一个持久化队列。

### 🔴 双队列架构

```
┌─────────────────────────────────────────────────────────────┐
│                        同步队列系统                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  UPLOAD QUEUE (上传队列) - 优先执行                    │   │
│  │  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━   │   │
│  │                                                      │   │
│  │  Priority 1: DELETE 操作                             │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │ { type: delete, entity: Score, id: xxx }        │ │   │
│  │  │ { type: delete, entity: InstrumentScore, ... }  │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  │                                                      │   │
│  │  Priority 2: CREATE 操作                             │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │ { type: create, entity: Score, data: {...} }    │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  │                                                      │   │
│  │  Priority 3: UPDATE 操作                             │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │ { type: update, entity: Setlist, data: {...} }  │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  │                                                      │   │
│  │  Priority 4: FILE UPLOAD 操作                        │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │ { type: upload, file: xxx.pdf, entityId: ... }  │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────┘   │
│                           │                                  │
│                           ▼                                  │
│                  [等待上传队列清空]                           │
│                           │                                  │
│                           ▼                                  │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  DOWNLOAD QUEUE (下载队列) - 上传完成后执行             │   │
│  │  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━   │   │
│  │                                                      │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │ 1. Incremental Pull (增量拉取)                  │ │   │
│  │  │ 2. PDF Download (文件下载)                      │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 上传队列特性

1. **持久化：** 队列数据存在 SyncState 表，App 被杀掉重启后，未完成的操作依然存在。

2. **幂等性：** 每个操作有唯一的 idempotency key（格式：`{entityType}:{entityId}:{operationType}:{version}`），重复入队会被自动忽略。

3. **严格优先级排序：**
   ```
   优先级从高到低：
   1. 删除操作 (DELETE)     - 必须最先执行
   2. 创建操作 (CREATE)     - 依赖关系要求先于更新
   3. 更新操作 (UPDATE)     - 普通修改
   4. 文件上传 (FILE_UPLOAD) - 大文件，最后处理
   ```

4. **依赖关系：** 某些操作有依赖，比如必须先创建 Score 并拿到 serverId，才能创建它的 InstrumentScore。队列会自动处理这种依赖。

5. **失败处理与重试：**
   ```
   失败的操作处理流程：
   ┌──────────────────────────────────────────────┐
   │  操作执行失败                                 │
   │       ↓                                      │
   │  检查重试次数 < 3?                            │
   │       ↓ Yes              ↓ No                │
   │  等待 (指数退避)          标记为永久失败        │
   │  2s → 4s → 8s            需要用户介入         │
   │       ↓                                      │
   │  重新放回队列顶部                             │
   │  (保持原优先级)                               │
   │       ↓                                      │
   │  ⚠️ 阻止下载队列执行                          │
   │  直到此操作成功或标记失败                      │
   └──────────────────────────────────────────────┘
   ```

### 下载队列特性

1. **前置条件：** 只有上传队列完全清空后才会执行
2. **内容：** 增量拉取 + PDF 文件下载
3. **失败处理：** 下载失败不会阻止后续操作，标记后稍后重试

---

## 第七部分：数据库设计要点

### 同步字段规范

每个需要同步的实体表，都应该包含以下字段：

1. **id** - 本地 UUID，客户端生成，永不改变
2. **serverId** - 服务器端自增 ID，首次同步成功后由服务器返回并存储
3. **version** - 版本号，每次本地修改 +1，用于冲突检测
4. **syncStatus** - 同步状态：pending（待同步）/ synced（已同步）/ conflict（有冲突）
5. **updatedAt** - 最后修改时间戳，用于 LWW 判断
6. **deletedAt** - 软删除时间戳，null 表示未删除

### MuSheet 当前表结构

| 表名 | 有同步字段 | 备注 |
|-----|-----------|------|
| Scores | ✅ | 完整同步字段 |
| InstrumentScores | ✅ | 包含额外的 pdfSyncStatus, pdfHash |
| Setlists | ✅ | 完整同步字段 |
| SetlistScores | ❌ | 关联表，暂无同步字段，需要后续添加 |
| Annotations | ❌ | 暂无同步字段，需要后续添加 |

### 待完善项

- **Annotations 表**：需要添加 version, syncStatus, serverId, updatedAt 字段
- **SetlistScores 表**：需要添加同步字段，或者改为跟随 Setlist 整体同步（把曲目列表 JSON 化存在 Setlist 里）

---

## 第八部分：实现路线图

### 已完成

- SyncServiceV2 核心框架（状态机、操作队列、冲突解决器）
- RpcClient 封装（类型安全的 Serverpod 调用）
- Score 和 InstrumentScore 的 Push/Pull 同步
- Setlist 基础同步
- PDF 文件上传下载
- 基础的错误重试机制

### 待实现

- Annotation 同步逻辑（需要先给表加同步字段）
- SetlistScore 同步（曲单内的曲目排序同步）
- 防抖批量上传（用于 Annotation 高频写入场景）
- 网络状态监听触发
- App 生命周期触发
- 同步进度 UI 展示
- 用户手动冲突解决界面

---

## 总结

| 用户动作 | UI 表现 | 本地数据库 | 网络行为 | 策略关键词 |
|---------|---------|-----------|---------|-----------|
| **打开 App** | 立即显示曲库列表 | 读取本地缓存 | 后台异步拉取增量 | 静默更新 |
| **打开 PDF** | 立即显示已有标注 | 读取本地缓存 | 后台拉取该 PDF 标注 | 范围拉取 |
| **修改 Score 信息** | 立刻生效 | 写入 (pending) | 定时/触发上传 | 乐观 UI |
| **画一笔标注** | 立刻显示 | 写入 (dirty) | 延迟 2s 批量上传 | 乐观 UI + 防抖 |
| **删除乐谱/曲单** 🔴 | 立刻移除 | 标记 (pending_delete) | **优先上传删除** | 上传优先 + 级联删除 |
| **导入 PDF** | 显示进度 | 写入 (pending) | 后台队列上传 | 任务队列 |
| **离线操作** | 正常使用 | 写入 (pending) | 操作进入队列 | 离线优先 |
| **网络恢复** | 无感知 | 标记 (synced) | **上传优先，再下载** | 自动恢复 |
| **检测到冲突** | 可选提示 | 自动解决或标记 | 等待处理 | LWW (含删除) |

---

## 关键改进点 (v2.0)

本次更新解决了以下同步逻辑漏洞：

### ✅ 已修复的问题

1. **删除操作未同步到后端**
   - 新增完整的删除同步流程（第二部分第 1 节）
   - 删除操作以最高优先级加入上传队列

2. **删除被服务器数据覆盖**
   - 实现严格的上传优先队列（第二部分开头）
   - 上传队列完全清空后才执行下载

3. **删除冲突处理不一致**
   - 删除操作现在遵循 LWW 原则（第四部分）
   - 比较时间戳而非简单恢复

4. **级联删除处理缺失**
   - 新增级联删除规则表（第二部分第 2 节）
   - 父实体删除自动处理子实体

5. **PDF 文件删除处理缺失**
   - 本地 PDF 在同步成功后删除（第二部分第 3 节）
   - 服务器 PDF 保留 30 天

6. **失败重试机制不完善**
   - 失败操作重新放回队列（第六部分）
   - 指数退避重试策略
   - 失败操作阻止下载执行

只要按这个逻辑实现，用户在任何网络条件下使用 MuSheet 都会感觉"丝滑"——操作响应即时，同步静默进行，离线也能正常使用，**删除操作也能正确同步**。
