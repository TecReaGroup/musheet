# MuSheet 离线优先同步策略

---

> **注意**：本文档描述的是当前开发中的同步架构，参考 Zotero 设计。

---

## 核心架构原则

1. **UI 的唯一真理是本地数据库**：UI 永远不等待网络，只读写本地 Drift (SQLite)。用户的每一次操作都应该立刻得到响应，不存在"正在加载"的等待状态。

2. **网络只是搬运工**：后台的 SyncService 负责把本地和云端的数据差异抹平。用户完全不需要关心"同步"这件事，一切都在后台静默完成。

3. **双通道分离**（参考 Zotero）：
   - **元数据通道**：Score、Setlist、Annotation 等结构化数据，使用版本号同步
   - **文件通道**：PDF 文件使用 Hash 校验，只在需要时下载/上传

4. **Library-Wide Version**（参考 Zotero 设计）：
   - 整个用户库只有一个全局版本号 `libraryVersion`
   - 不再追踪每条记录的单独 version
   - 彻底解决设备时钟不准导致的同步问题

5. **本地操作优先**：尽量同步所有版本，实在无法合并则本地操作覆盖云端。

---

## 设计灵感：Zotero 的双通道同步

Zotero 是开源界的神级同步方案，其核心智慧：

```
┌─────────────────────────────────────────────────────────────┐
│                    Zotero 双通道架构                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  📊 数据通道 (Data Syncing)                                  │
│  ─────────────────────────────────────────────────────────   │
│  内容：标题、作者、标签、笔记、关联关系                         │
│  特点：极其轻量，速度极快                                     │
│  版本控制：Library-Wide Version（单一整数）                   │
│                                                             │
│  📁 文件通道 (File Syncing)                                  │
│  ─────────────────────────────────────────────────────────   │
│  内容：PDF 原文、附件                                         │
│  特点：流量大、存储贵                                         │
│  版本控制：Hash 校验（文件不修改，只替换）                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**MuSheet 采纳此架构：**
- Serverpod 同步元数据（轻量、自建）
- PDF 文件使用 Hash 对比，懒加载下载

---

## MuSheet 数据模型概览

在深入同步策略前，先理解 MuSheet 的数据结构：

- **Score（乐谱）**：一首曲子的基本信息，如《月光奏鸣曲》。包含标题、作曲家、BPM。
- **InstrumentScore（乐器分谱）**：一首曲子的某个乐器版本，如《月光奏鸣曲 - 小提琴谱》。每个分谱关联一个 PDF 文件。一首 Score 可以有多个 InstrumentScore。
- **Annotation（标注）**：用户在某个 InstrumentScore 的 PDF 上画的笔记，如划线、圈注、文字标注。
- **Setlist（曲单）**：用户创建的演出曲目列表，如"周六晚演出"。
- **SetlistScore（曲单曲目）**：Setlist 和 Score 的关联关系，包含排序。

### 同步分类

| 实体类型 | 同步通道 | 版本控制方式 |
|---------|---------|-------------|
| Score | 元数据通道 | libraryVersion |
| InstrumentScore | 元数据通道 | libraryVersion |
| Annotation | 元数据通道 | libraryVersion |
| Setlist | 元数据通道 | libraryVersion |
| SetlistScore | 元数据通道 | libraryVersion |
| PDF 文件 | 文件通道 | Hash 校验 |

---

## 第一部分：Library-Wide Version 版本控制（核心简化）

### 设计原理（参考 Zotero）

**方案（Zotero 风格）：**

```
整个用户库只有一个 libraryVersion（整数）
客户端问："我在版本 100，有更新吗？"
服务器答："这是 101-105 的所有变更"
```

### 版本号机制

```
┌─────────────────────────────────────────────────────────────┐
│                    Library Version 机制                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  服务器状态：                                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  libraryVersion = 105                                   │ │
│  │  每次任何数据变更，libraryVersion++                      │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
│  客户端请求：                                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  GET /sync?since=100                                    │ │
│  │  "我上次同步到版本 100，之后有什么变化？"                  │ │
│  └─────────────────────────────────────────────────────────┘ │
│                           ↓                                 │
│  服务器响应：                                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  {                                                      │ │
│  │    "libraryVersion": 105,                               │ │
│  │    "changes": [...版本 101-105 的所有变更...],           │ │
│  │    "deleted": ["key1", "key2"]                          │ │
│  │  }                                                      │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 每个实体的版本字段

每条记录都带有 `version` 字段（表示该记录是在哪个 libraryVersion 时被修改的）：

```dart
class Score {
  String id;           // 本地 UUID
  int version;         // 该记录的版本号（= 修改时的 libraryVersion）
  DateTime? deletedAt; // 软删除时间戳
  // ... 业务字段
}
```

### 同步流程简化

注意：
同步顺序铁律：Push 永远先于 Pull

即使使用 libraryVersion 简化了冲突检测，Push 优先级仍然必须高于 Pull。
这确保用户的本地操作不会被服务器数据意外覆盖。

```
┌─────────────────────────────────────────────────────────────┐
│                    简化的同步流程                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  STEP 1: Push（推送本地变更）                                │
│  ─────────────────────────────────────────────────────────   │
│  POST /sync                                                  │
│  Header: If-Unmodified-Since-Version: 100                    │
│  Body: { changes: [...所有待同步项...] }                     │
│                                                             │
│  响应处理：                                                  │
│  ├─ 200 OK                                                  │
│  │   └── 服务器接受变更，返回新的 libraryVersion             │
│  │       本地更新 libraryVersion，标记 synced                │
│  │                                                          │
│  └─ 412 Precondition Failed（版本冲突）                      │
│      └── 说明有其他设备先提交了                              │
│          执行 STEP 2 拉取合并，然后重试                      │
│                                                             │
│  STEP 2: Pull（仅在 412 时执行，或定期执行）                  │
│  ─────────────────────────────────────────────────────────   │
│  GET /sync?since=100                                         │
│  响应: { libraryVersion: 105, changes: [...], deleted: [...] } │
│                                                             │
│  本地合并后，重试 STEP 1                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第二部分：下载策略 (Pull Strategy)

我们将下载分为两类场景：元数据同步 和 PDF 文件下载。

### 1. 元数据增量同步 (Metadata Incremental Sync)

**场景：** 用户打开 App，看到曲库列表和曲单列表。

**策略：** **"静默增量更新 (Silent Incremental Update)"**

1. **即时渲染：** App 启动，立刻读取本地 Drift 数据库，展示上次缓存的曲库和曲单。用户看到的永远是"有东西"的状态，不是空白页。

2. **后台询问：** SyncService 向 Serverpod 后端发起请求：
   ```
   GET /sync?since={localLibraryVersion}
   "我上次同步到版本 100，之后有什么变化？"
   ```

3. **增量拉取：**
   - **无变化：** 后端返回 `libraryVersion` 与本地相同，空 changes 列表。结束。
   - **有变化：** 后端返回所有变更的实体 + 被删除的 key 列表。

4. **合并写入：** 同步服务将变更合并到本地数据库：
   - 新增/更新的记录直接覆盖本地
   - deleted 列表中的 key 标记为删除
   - 更新本地 `libraryVersion`

5. **UI 响应：** 通过 Riverpod 的 AsyncNotifier，数据库变动自动触发 UI 刷新。

### 2. PDF 文件下载 (PDF Asset Download) — 文件通道

**场景：** 用户点击了一个 InstrumentScore，但本地还没有对应的 PDF 文件，或者云端有更新版本。

**PDF 不使用版本号，只用 Hash 校验**

PDF 文件的特点：不会被"修改"，只会被"替换"。因此不需要版本号，只需要 Hash 比对。

**策略：** **"懒加载 + 缓存优先 + Hash 校验 (Lazy Load & Cache-First)"**

1. **检查本地缓存：** 检查 pdfPath 指向的文件是否存在。

2. **Hash 校验：** 如果本地有文件，比较本地 `pdfHash` 和服务器记录的 Hash。
   - **Hash 一致：** 直接使用本地文件，零网络请求。
   - **Hash 不一致：** 说明 PDF 被替换了，需要重新下载。

3. **状态分支：**
   - **有缓存且 Hash 一致：** 直接打开本地 PDF。
   - **无缓存或 Hash 不一致：** 显示下载进度 → 流式下载写入本地 → 计算并存储 pdfHash → 打开。

4. **后台预加载：** 在 WiFi 环境下，可以预先下载用户曲库中还没有本地缓存的 PDF，但这是低优先级任务。

```
PDF 同步决策树：
┌─────────────────────────────────────────┐
│  打开 InstrumentScore                    │
│       ↓                                 │
│  本地有 PDF 文件？                       │
│       ↓ Yes              ↓ No           │
│  比较 Hash                下载 PDF       │
│       ↓                                 │
│  Hash 一致？                             │
│       ↓ Yes              ↓ No           │
│  直接打开                重新下载        │
└─────────────────────────────────────────┘
```

---

## 第三部分：上传策略 (Push Strategy)

### 简化的推送机制（参考 Zotero）

**核心变化：不再需要复杂的优先级队列**

Zotero 使用 `If-Unmodified-Since-Version` 头实现乐观并发控制。如果版本冲突，先拉取合并，再重试推送。

```
简化后的同步流程：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  STEP 1: 收集本地变更                                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  - 所有 syncStatus = pending 的记录                      │ │
│  │  - 所有 syncStatus = pending_delete 的记录               │ │
│  │  - 打包成一个批量请求                                    │ │
│  └─────────────────────────────────────────────────────────┘ │
│                           ↓                                  │
│  STEP 2: 推送到服务器                                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  POST /sync                                              │ │
│  │  Header: If-Unmodified-Since-Version: {localVersion}     │ │
│  │  Body: { changes: [...], deletes: [...] }                │ │
│  └─────────────────────────────────────────────────────────┘ │
│                           ↓                                  │
│  STEP 3: 处理响应                                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  200 OK → 更新 libraryVersion，标记 synced                │ │
│  │  412 Conflict → 拉取合并，然后重试 STEP 2                 │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘

为什么这样更简单？
- 服务器通过版本号自动检测冲突
- 冲突时自动触发拉取-合并-重试流程
```

### 1. 元数据上传

**策略：** **"写入即忘 + 批量推送 (Fire-and-Forget & Batch Push)"**

1. **用户操作：** 创建一个新 Score，添加一个 InstrumentScore，或者修改 Setlist 名称等等。

2. **写入本地：** 立刻存入 Drift 数据库，标记 `syncStatus = pending`。UI 通过 Riverpod 立刻更新。

3. **触发同步：** 在合适的时机（定时器、App 切后台、网络恢复）执行批量上传。

4. **批量上传：** 收集所有 pending 状态的记录，一次性推送到服务器。

5. **回调处理：**
   - **200 OK：** 更新本地 `libraryVersion`，标记 `syncStatus = synced`
   - **412 Conflict：** 拉取服务器变更，合并后重试

### 2. 删除操作同步（软删除机制）

**策略：** **"立即标记 + 批量推送 (Immediate Mark & Batch Push)"**

#### 为什么需要软删除？

软删除是同步架构的核心机制。如果使用物理删除（直接从数据库删除记录），则：
- 本地记录消失，没有任何"删除"的痕迹
- 无法告诉服务器"我删除了这条记录"
- 其他设备永远不知道这条记录被删了

**软删除使删除操作能够被纳入版本控制：**

```
libraryVersion = 100
       ↓
用户删除 Score（标记 deletedAt）
       ↓
libraryVersion = 101（删除操作也算一次变更）
       ↓
其他设备 Pull since=100 时能获取到这个删除信息
```

#### 删除流程

1. **用户操作：** 用户删除一个 Score。

2. **本地处理：**
   ```
   - 标记 Score.deletedAt = DateTime.now()
   - 标记 Score.syncStatus = pending_delete
   - 级联标记所有关联的 InstrumentScore.deletedAt
   - 级联标记所有关联的 Annotation.deletedAt
   - 级联标记所有关联的 SetlistScore.deletedAt
   ```

3. **UI 响应：**
   - 立刻从列表中移除该项（乐观 UI）
   - 被删除的记录不再显示，但仍保留在数据库中等待同步

4. **同步执行：**
   - 删除操作与其他变更一起打包推送
   - 服务器接收后标记 `deletedAt`，更新 `libraryVersion++`
   - 服务器返回成功后，本地可进行物理删除（见下文清理策略）

#### 删除记录保留策略

**服务器端：**
- 软删除的元数据记录**永久保留**（直到用户删除账号）
- 这确保任何时间点离线的设备都能正确同步删除信息
- 关联的 PDF 文件**立即删除**（因为已被删除的分谱不会再被任何设备请求）
- 元数据记录体积小，永久保留成本可接受

**客户端：**
- 同步成功后可立即物理删除本地记录
- 同步成功后立即删除本地 PDF 文件

```
删除记录生命周期：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  用户删除记录                                                │
│       ↓                                                     │
│  本地标记 deletedAt + syncStatus = pending_delete            │
│       ↓                                                     │
│  Push 到服务器                                               │
│       ↓                                                     │
│  服务器标记 deletedAt，libraryVersion++                      │
│  服务器立即删除关联的 PDF 文件                               │
│       ↓                                                     │
│  其他设备 Pull 时获取 deleted 列表                           │
│       ↓                                                     │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  服务器永久保留删除的元数据记录                           │ │
│  │  - 确保任何离线设备都能同步删除信息                       │ │
│  │  - 用户删除账号时才物理清理元数据                         │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. 级联删除规则

| 删除的实体 | 级联影响 | 处理方式 |
|-----------|---------|---------|
| **Score** | InstrumentScores, Annotations, SetlistScores | 全部标记 deletedAt |
| **InstrumentScore** | Annotations (该分谱的), PDF 文件 | Annotations 标记删除，PDF 本地删除 |
| **Setlist** | SetlistScores | 关联记录标记删除 |
| **Annotation** | 无 | 仅删除自身 |

### 4. PDF 文件上传

**策略：** **"任务队列 + Hash 去重 (Task Queue & Deduplication)"**

1. **用户操作：** 导入一个 PDF 作为新的 InstrumentScore。

2. **本地处理：**
   - 复制 PDF 文件到 App 私有目录
   - 计算文件 MD5 Hash
   - 创建 InstrumentScore 记录，pdfSyncStatus = pending

3. **Hash 去重：** 上传前先问服务器："有没有 Hash 为 xxx 的文件？"如果有，直接关联，跳过上传（秒传）。

4. **执行上传：** 在后台线程上传文件。不阻塞 UI。

5. **完成：** 更新 pdfSyncStatus = synced，存储服务器返回的文件 URL。

---

## 第四部分：冲突解决策略 (Conflict Resolution)

### 核心原则：本地优先 + 尽量合并

与 Zotero 的 LWW（Last Write Wins）不同，MuSheet 采用更激进的策略：

**优先级：本地操作 > 云端数据**

如果无法自动合并，本地操作直接覆盖云端。理由：
- 用户刚刚做的操作应该被保留
- 避免用户困惑（"我明明改了，为什么又变回去了？"）

### 冲突场景处理

```
┌─────────────────────────────────────────────────────────────┐
│                    冲突解决流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PUSH 返回 412 Conflict                                     │
│       ↓                                                     │
│  PULL 拉取服务器最新数据                                     │
│       ↓                                                     │
│  尝试自动合并：                                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  场景 1: 不同字段被修改                                  │ │
│  │  → 自动合并（如 A 改标题，B 改 BPM）                     │ │
│  │                                                         │ │
│  │  场景 2: 同一字段被修改                                  │ │
│  │  → 本地值覆盖云端                                        │ │
│  │                                                         │ │
│  │  场景 3: 本地删除 vs 云端修改                            │ │
│  │  → 保持删除（用户意图优先）                              │ │
│  │                                                         │ │
│  │  场景 4: 云端删除 vs 本地修改                            │ │
│  │  → 恢复记录，应用本地修改                                │ │
│  └─────────────────────────────────────────────────────────┘ │
│       ↓                                                     │
│  重新 PUSH 合并后的数据                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 冲突粒度

- **Score / Setlist / InstrumentScore：** 冲突粒度是**整条记录**
- **Annotation：** 冲突粒度是**单个标注**。不同标注互不影响

### 标注的特殊处理

标注采用"追加式合并"：
- 用户 A 在第 1 页画了一笔，用户 B 在第 2 页画了一笔 → 两者都保留
- 只有修改同一个 Annotation（相同 UUID）才算冲突，此时本地版本胜出

---

## 第五部分：特殊场景处理

### 1. 首次登录 / 新设备同步

当用户在新设备登录时，`libraryVersion = 0`，需要全量拉取数据。

**分优先级同步策略：**

```
首次同步流程：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  PHASE 1: 核心元数据（立即可见）                              │
│  ─────────────────────────────────────────────────────────   │
│  - Score（乐谱基本信息）                                     │
│  - Setlist（曲单）                                          │
│  - InstrumentScore（分谱元数据，不含 PDF）                    │
│  → 用户可以立即看到曲库列表                                  │
│                                                             │
│  PHASE 2: 按需加载                                          │
│  ─────────────────────────────────────────────────────────   │
│  - Annotation（标注）：进入 ScoreViewer 时才拉取              │
│  - PDF 文件：完全懒加载，打开分谱时才下载                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**设计理由：**
- 用户首次登录时应尽快看到曲库内容
- Annotation 和 PDF 体积大，且只有打开对应分谱时才需要
- 减少首次同步等待时间

### 2. 超长离线后的同步

服务器永久保留删除的元数据记录（直到用户账号被删除），确保任何时间点离线的设备都能正确同步删除信息。

即使用户设备离线 2 年后再上线，也能正确同步所有删除操作。

### 3. 批量操作与 PDF 上传策略

**PDF 串行上传：**

```
PDF 上传策略：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  用户导入 100 个 PDF：                                       │
│  ─────────────────────────────────────────────────────────   │
│  1. 所有 InstrumentScore 元数据立即写入本地                   │
│  2. UI 立即显示新增的 100 个分谱（无 PDF 状态）               │
│  3. PDF 文件进入上传队列，串行上传                           │
│  4. 上传进度可在 Settings → Sync 页面查看                    │
│                                                             │
│  为什么串行而非并发？                                        │
│  - 避免占用过多带宽影响用户其他网络活动                       │
│  - 避免服务器压力                                            │
│  - 便于实现队列管理和失败重试                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 网络中断处理

**PDF 上传/下载中断：从头开始**

```
网络中断策略：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  场景：10MB PDF 上传到 80% 时网络断开                         │
│  处理：网络恢复后从头开始上传                                 │
│                                                             │
│  理由：                                                      │
│  - 实现简单，避免分片上传的复杂性                            │
│  - PDF 文件通常 <10MB，重传成本可接受                         │
│  - 用户乐谱 PDF 一般压缩后 1-5MB                             │
│                                                             │
│  优化：                                                      │
│  - 在 WiFi 环境下优先上传                                    │
│  - 网络不稳定时暂停大文件上传                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5. 多客户端同步

**策略：下次打开时刷新**

```
多客户端场景：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  用户在 iPad 和 iPhone 上同时使用 MuSheet：                   │
│  ─────────────────────────────────────────────────────────   │
│  - iPad 修改了 Score 标题                                    │
│  - iPhone 正在浏览同一个 Score                               │
│                                                             │
│  处理策略：                                                  │
│  - 不做实时推送通知                                          │
│  - iPhone 下次打开 App 或手动刷新时拉取最新数据               │
│  - 5 分钟定时同步也会自动拉取                                │
│                                                             │
│  理由：                                                      │
│  - 避免 WebSocket 实时连接的复杂性                           │
│  - 乐谱应用不需要实时协作                                    │
│  - 简化架构，降低服务器成本                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6. 同步错误展示

**错误信息展示在 Settings → Sync 页面：**

```
同步错误处理：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  错误类型与展示：                                            │
│  ─────────────────────────────────────────────────────────   │
│  1. 网络错误 → "网络连接失败，将自动重试"                     │
│  2. 服务器错误 → "服务器暂时不可用"                          │
│  3. 冲突错误 → "部分数据冲突，已自动解决"                     │
│  4. 上传失败 → "N 个文件待上传"                              │
│                                                             │
│  Settings → Sync 页面显示：                                  │
│  - 最后同步时间                                              │
│  - 同步状态（成功/失败/进行中）                               │
│  - 待上传文件数量                                            │
│  - 错误详情（如有）                                          │
│  - 手动同步按钮                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第六部分：触发机制 (Triggers)

同步不是"用户点击同步按钮"才发生的，而是由一系列自动触发器驱动的。

### 1. 定时触发 (Periodic Timer)

- **间隔：** 5 分钟（登录后或加入app后则立即同步）
- **动作：** 触发完整同步流程（Push → Pull）
- **目的：** 保证数据不会太旧

### 2. 数据变更触发 (On Data Modified)

- **监听：** 任何数据写入本地数据库
- **动作：** 触发延迟同步（防抖 5 秒）
- **目的：** 用户修改尽快上云

### 3. 生命周期触发 (App Lifecycle)

- **监听：** App 从后台切回前台
- **动作：** 触发 Pull 拉取最新数据
- **目的：** 用户可能在其他设备上做了修改

### 4. 网络状态触发 (Connectivity)

- **监听：** 网络从断开变为连接
- **动作：** 触发 Push 重试 + Pull
- **目的：** 自动灾难恢复

### 5. 场景进入触发 (Navigation Based)

- **监听：** 用户进入 ScoreViewerScreen
- **动作：** 触发当前 InstrumentScore 的 PDF 下载检查
- **目的：** 按需加载，节省流量

### 6. 手动触发 (User Action)

- **监听：** 用户点击"同步"按钮
- **动作：** 立即执行完整同步流程

---

## 第七部分：同步状态机 (State Machine)

### 状态定义

1. **空闲 (Idle)：** 没有同步任务在执行
2. **推送中 (Pushing)：** 正在上传本地变更
3. **拉取中 (Pulling)：** 正在下载服务器变更
4. **合并中 (Merging)：** 正在处理冲突
5. **等待网络 (Waiting for Network)：** 同步时发现没网，暂停同步
6. **错误 (Error)：** 发生错误，会自动重试

### 状态转换

```
┌─────────────────────────────────────────────────────────────┐
│                        状态转换图                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [Idle] ──触发同步──→ [Pushing]                              │
│    ↑                      │                                 │
│    │                      ├─ 200 OK ──→ [Pulling]           │
│    │                      │                  │              │
│    │                      │                  ├─ 完成 ──→ [Idle]
│    │                      │                  │              │
│    │                      └─ 412 ──→ [Pulling] ──→ [Merging] │
│    │                                              │         │
│    │                                              └─→ [Pushing]
│    │                                                        │
│    └─────────────────── 网络断开 ───→ [Waiting for Network] ─┘
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第八部分：数据库设计（简化版）

### 同步字段规范

每个需要同步的实体表包含以下字段：

| 字段 | 类型 | 说明 |
|-----|------|------|
| `id` | String | 本地 UUID，客户端生成 |
| `version` | int | 该记录的版本号（= 修改时的 libraryVersion） |
| `syncStatus` | enum | pending / synced / pending_delete |
| `deletedAt` | DateTime? | 软删除时间戳，null 表示未删除 |

### 全局同步状态表

```dart
class SyncState {
  int libraryVersion;      // 本地已同步到的版本号
  DateTime lastSyncAt;     // 最后同步时间
  String? syncError;       // 最后一次同步错误信息
}
```

---

## 第九部分：API 设计（简化版）

### 统一同步接口

只需要两个核心接口：

#### 1. Push 接口

```
POST /sync
Header: If-Unmodified-Since-Version: {localLibraryVersion}

Request Body:
{
  "changes": [
    { "type": "Score", "id": "xxx", "data": {...} },
    { "type": "Annotation", "id": "yyy", "data": {...} }
  ],
  "deletes": [
    { "type": "Score", "id": "zzz" }
  ]
}

Response (200 OK):
{
  "libraryVersion": 106,
  "accepted": ["xxx", "yyy", "zzz"]
}

Response (412 Conflict):
{
  "libraryVersion": 105,
  "message": "Version mismatch, please pull first"
}
```

#### 2. Pull 接口

```
GET /sync?since={version}

Response:
{
  "libraryVersion": 105,
  "changes": [
    { "type": "Score", "id": "xxx", "version": 103, "data": {...} },
    { "type": "Setlist", "id": "yyy", "version": 105, "data": {...} }
  ],
  "deleted": ["key1", "key2"]
}
```

---

## 总结

| 用户动作 | UI 表现 | 本地数据库 | 网络行为 | 策略关键词 |
|---------|---------|-----------|---------|-----------|
| **打开 App** | 立即显示曲库列表 | 读取本地缓存 | 后台 Pull | 静默更新 |
| **打开 PDF** | 立即显示 | 检查 Hash | 按需下载 | Hash 校验 |
| **修改 Score 信息** | 立刻生效 | 写入 (pending) | 批量 Push | 乐观 UI |
| **画一笔标注** | 立刻显示 | 写入 (pending) | 延迟 5s 批量上传 | 防抖 |
| **删除乐谱** | 立刻移除 | 标记 (pending_delete) | 批量 Push | 级联删除 |
| **导入 PDF** | 显示进度 | 写入 (pending) | 后台队列上传 | Hash 去重 |
| **离线操作** | 正常使用 | 写入 (pending) | 网络恢复后 Push | 离线优先 |
| **版本冲突** | 无感知 | 自动合并/本地优先 | Pull → Merge → Push | 本地优先 |

---

## 附录：限制与约束

### 文件大小限制

| 限制项 | 值 | 说明 |
|-------|-----|------|
| 单个 PDF 最大文件大小 | **70 MB** | 超过此大小的 PDF 将被拒绝上传 |

### 账号与数据策略

| 场景 | 处理方式 |
|-----|---------|
| 用户登出 | **不清理本地数据** |
| 用户删除账号 | **不清理本地数据** |
| 多账号切换 | **不清理本地数据** |

**设计理由：**
- 本地数据保留，可直接迁移到新服务器
- 用户可手动清理 App 缓存释放空间
- 简化实现复杂度

### 不支持的功能

- ❌ 数据恢复/回滚
- ❌ 同步历史查看
- ❌ 撤销删除操作

---

## 核心理念（参考 Zotero）

1. **双通道分离**：元数据用版本号，PDF 用 Hash
2. **Library-Wide Version**：解决设备时钟问题
3. **乐观并发控制**：If-Unmodified-Since-Version 头
4. **本地优先**：冲突时本地操作覆盖云端

---

**Zotero 证明了：不需要实时 WebSocket，不需要复杂的 CRDT，仅靠"全局版本号 + 元数据/文件分离"，就能支撑起百万级用户的同步需求。**
