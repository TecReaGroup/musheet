# MuSheet App 端完整同步逻辑

本文档描述 MuSheet Flutter App 的完整同步架构，采用**元数据通道**与**文件通道**完全分离的设计。

---

## 目录

1. [总体同步逻辑](#1-总体同步逻辑)
2. [元数据同步详解](#2-元数据同步详解)
3. [PDF 文件同步详解](#3-pdf-文件同步详解)

---

## 1. 总体同步逻辑

### 1.1 核心架构原则

```
┌─────────────────────────────────────────────────────────────────────┐
│                        MuSheet 同步架构                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ┌──────────────┐         ┌──────────────┐                         │
│   │   元数据通道   │         │   文件通道    │                         │
│   │  (Metadata)  │         │    (PDF)     │                         │
│   ├──────────────┤         ├──────────────┤                         │
│   │ Score        │         │              │                         │
│   │ InstrumentScore ───────┼─→ pdfHash ───┼─→ PDF 文件               │
│   │ Annotation   │         │              │                         │
│   │ Setlist      │         │ 引用计数管理   │                         │
│   │ SetlistScore │         │              │                         │
│   └──────────────┘         └──────────────┘                         │
│         │                         │                                  │
│         ▼                         ▼                                  │
│   libraryVersion            pdfHash (MD5)                           │
│   (全局版本号)               (内容寻址)                               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**设计原则：**

| 原则 | 说明 |
|------|------|
| **UI 读写本地** | 所有操作立即写入本地 SQLite，UI 永不等待网络 |
| **Push 先于 Pull** | 铁律：总是先推送本地变更，再拉取服务器数据 |
| **本地优先** | 冲突时，pending 状态的本地数据优先保留（如果是 synced 则服务器优先） |
| **双通道分离** | 元数据和 PDF 使用独立的同步队列和版本控制 |
| **PDF 引用计数** | 相同内容的 PDF 只存一份，通过 Hash 引用 |

### 1.2 同步状态机

```
                    ┌─────────────────────────────────────┐
                    │                                     │
                    ▼                                     │
    ┌───────┐   trigger   ┌─────────┐   success    ┌──────┴──┐
    │ idle  │ ──────────► │ syncing │ ───────────► │  idle   │
    └───────┘             └─────────┘              └─────────┘
        │                      │
        │ no network           │ error / 412 conflict
        ▼                      ▼
    ┌────────────────┐    ┌─────────┐   retry(30s)
    │ waitingNetwork │    │  error  │ ─────────────┐
    └────────────────┘    └─────────┘              │
        │                      ▲                    │
        │ network restored     └────────────────────┘
        ▼
    ┌─────────┐
    │ syncing │
    └─────────┘
```

**同步阶段（syncing 内部）：**

```
syncing
  ├─► pushing     (推送本地变更)
  │     │
  │     ├─► 412 Conflict ─► pulling ─► merging ─► pushing (重试)
  │     │
  │     └─► success
  │
  ├─► pulling     (拉取服务器变更)
  │
  ├─► merging     (合并数据)
  │
  └─► pdfSyncing  (PDF 文件同步，独立队列)
```

### 1.3 触发机制

| 触发条件 | 动作 | 说明 |
|---------|------|------|
| **本地数据变更** | 防抖 5s 后同步 | 避免频繁操作时过多请求 |
| **App 启动** | 立即同步 | 获取最新数据 |
| **App 从后台恢复** | 立即 Pull | 可能有其他设备的变更 |
| **网络恢复** | 立即同步 | 处理离线期间的变更 |
| **定时同步** | 每 5 分钟 | 后台保活时的增量同步 |
| **用户手动刷新** | 立即同步 | 下拉刷新等操作 |
| **用户登录** | 全量同步 | libraryVersion = 0 |
| **用户切换账号** | 清空本地 + 全量同步 | 切换到新账号的数据 |

### 1.4 完整同步流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        完整同步周期                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 1: PUSH 元数据                                            ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  1. 收集待同步数据:                                              ║ │
│  ║     ┌─────────────────────────────────────────────────┐        ║ │
│  ║     │ syncStatus = 'pending'       → 新建/修改的记录   │        ║ │
│  ║     │ syncStatus = 'pending_delete' → 待删除的记录     │        ║ │
│  ║     └─────────────────────────────────────────────────┘        ║ │
│  ║                                                                 ║ │
│  ║  2. 按依赖顺序排序:                                              ║ │
│  ║     ┌────────────────────────────────────────────────┐         ║ │
│  ║     │ 第1批: Scores, Setlists (无依赖)                │         ║ │
│  ║     │ 第2批: InstrumentScores (依赖 Score)           │         ║ │
│  ║     │ 第3批: Annotations (依赖 InstrumentScore)      │         ║ │
│  ║     │ 第4批: SetlistScores (依赖 Setlist + Score)    │         ║ │
│  ║     └────────────────────────────────────────────────┘         ║ │
│  ║                                                                 ║ │
│  ║  3. 发送请求: POST /library/push                                ║ │
│  ║     请求体包含 clientLibraryVersion 和各实体数组                 ║ │
│  ║     instrumentScores 只含 pdfHash，不含实际文件                  ║ │
│  ║                                                                 ║ │
│  ║  4. 处理响应:                                                    ║ │
│  ║     ┌─────────────────────────────────────────────────────┐    ║ │
│  ║     │ 200 OK:                                              │    ║ │
│  ║     │   • 保存 serverId 映射                               │    ║ │
│  ║     │   • 更新 syncStatus = 'synced'                      │    ║ │
│  ║     │   • 更新本地 libraryVersion                          │    ║ │
│  ║     │   • 物理删除 pending_delete 记录                     │    ║ │
│  ║     ├─────────────────────────────────────────────────────┤    ║ │
│  ║     │ 412 Conflict:                                        │    ║ │
│  ║     │   • 跳到阶段 2 拉取数据                              │    ║ │
│  ║     │   • 合并后重试 Push                                  │    ║ │
│  ║     └─────────────────────────────────────────────────────┘    ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                │                                     │
│                                ▼                                     │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 2: PULL 元数据                                            ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  1. 请求增量数据: GET /library/pull?since={version}             ║ │
│  ║                                                                 ║ │
│  ║  2. 响应包含:                                                    ║ │
│  ║     • libraryVersion (最新版本号)                               ║ │
│  ║     • 各实体数组 (scores, instrumentScores 含 pdfHash, etc.)    ║ │
│  ║     • deleted 数组 (已删除实体的标识)                            ║ │
│  ║                                                                 ║ │
│  ║  3. 合并策略 (详见 §2.4):                                        ║ │
│  ║     • 本地 pending → 保留本地                                    ║ │
│  ║     • 本地 synced  → 使用服务器数据                              ║ │
│  ║     • 本地不存在   → 创建新记录                                  ║ │
│  ║                                                                 ║ │
│  ║  4. 更新本地 libraryVersion                                     ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                │                                     │
│                                ▼                                     │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 3: PDF 文件同步 (独立队列)                                  ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  此阶段完全独立于元数据同步，详见 §3                              ║ │
│  ║                                                                 ║ │
│  ║  1. 上传队列: pdfSyncStatus = 'pending'                         ║ │
│  ║  2. 下载队列: pdfSyncStatus = 'needsDownload'                   ║ │
│  ║  3. 引用计数: 基于 pdfHash 管理文件生命周期                       ║ │
│  ║                                                                 ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.5 特殊场景

#### 1.5.1 新设备登录（全量同步）

```
┌─────────────────────────────────────────────────────────────────────┐
│  新设备登录流程                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 用户登录成功                                                      │
│     │                                                                │
│     ▼                                                                │
│  2. 初始化本地数据库                                                  │
│     libraryVersion = 0                                               │
│     │                                                                │
│     ▼                                                                │
│  3. Pull 全量元数据 (since = 0)                                      │
│     ┌─────────────────────────────────────────────┐                 │
│     │ 服务器返回所有: Scores, InstrumentScores,    │                 │
│     │ Setlists, SetlistScores                     │                 │
│     │ (不包含 Annotations，按需加载)               │                 │
│     └─────────────────────────────────────────────┘                 │
│     │                                                                │
│     ▼                                                                │
│  4. UI 立即可用                                                       │
│     用户可以看到曲库列表、曲单列表                                     │
│     │                                                                │
│     ▼                                                                │
│  5. PDF 按需下载                                                      │
│     用户打开某个分谱时才下载对应 PDF                                   │
│     │                                                                │
│     ▼                                                                │
│  6. Annotations 按需加载                                              │
│     打开分谱时加载该分谱的标注                                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.2 网络中断处理

```
┌─────────────────────────────────────────────────────────────────────┐
│  网络中断场景                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  同步过程中网络断开:                                                  │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 停止当前同步                                               │    │
│  │ • 状态 → waitingForNetwork                                  │    │
│  │ • 已成功的部分保留（不回滚）                                  │    │
│  │ • 未完成的部分等待重试                                       │    │
│  │ • 监听网络状态，恢复后立即重试                                │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  离线操作:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 所有操作正常写入本地数据库                                  │    │
│  │ • syncStatus = 'pending'                                    │    │
│  │ • UI 正常响应                                                │    │
│  │ • 网络恢复后自动同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  PDF 传输中断:                                                        │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 中止传输，标记失败                                         │    │
│  │ • 不支持断点续传（PDF 通常 1-10MB，重传成本可接受）           │    │
│  │ • 网络恢复后从头开始                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.3 用户切换账号

```
┌─────────────────────────────────────────────────────────────────────┐
│  账号切换流程                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 用户点击登出                                                      │
│     │                                                                │
│     ▼                                                                │
│  2. 检查是否有未同步数据                                              │
│     ├─ 有 → 提示用户 "有未同步的数据，确定登出？"                     │
│     │       ├─ 确定 → 继续                                           │
│     │       └─ 取消 → 返回                                           │
│     └─ 无 → 继续                                                     │
│     │                                                                │
│     ▼                                                                │
│  3. 停止同步服务                                                      │
│     │                                                                │
│     ▼                                                                │
│  4. 清空本地数据                                                      │
│     • 删除所有数据库表内容                                            │
│     • 删除所有本地 PDF 文件                                           │
│     • libraryVersion = 0                                             │
│     │                                                                │
│     ▼                                                                │
│  5. 新账号登录                                                        │
│     │                                                                │
│     ▼                                                                │
│  6. 全量同步（同 1.5.1）                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.4 App 退出

```
┌─────────────────────────────────────────────────────────────────────┐
│  App 退出处理                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  正常退出:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 所有本地数据已持久化到 SQLite                              │    │
│  │ • 未同步的数据保留 (syncStatus = 'pending')                  │    │
│  │ • 下次启动时自动同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  强制退出/崩溃:                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • SQLite 事务保证数据一致性                                  │    │
│  │ • 可能丢失当前正在进行的同步状态                              │    │
│  │ • 下次启动时重新同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.6 冲突解决总览

```
┌─────────────────────────────────────────────────────────────────────┐
│  冲突解决策略                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  版本冲突 (412 Conflict):                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 场景: 设备 A 和 B 都在 version=100，A 先提交成功              │    │
│  │       B 提交时服务器返回 412                                  │    │
│  │                                                              │    │
│  │ 处理: B 先 Pull → 合并 → 重试 Push                           │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  数据冲突:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 本地 syncStatus = 'pending' → 本地优先，保留本地修改          │    │
│  │ 本地 syncStatus = 'synced'  → 服务器优先，覆盖本地            │    │
│  │ 删除 vs 修改 → 删除优先 (用户明确意图)                        │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  PDF 冲突:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 基于 Hash 的内容寻址，不存在内容冲突                          │    │
│  │ 相同 Hash = 相同文件，无需处理                                │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

冲突解决样例：

T1: 服务器版本 = 10
      ├── 手机 A 本地版本 = 10
      └── 平板 B 本地版本 = 10

  T2: 手机 A Push "Song A" 成功
      服务器版本 = 11 ← 服务器递增
      手机 A 本地版本 = 11 ← 同步后更新

  T3: 平板 B 修改 "Song B"（本地版本仍 = 10，因为还没同步）

  T4: 平板 B Push，带着 clientLibraryVersion = 10
      服务器: 10 < 11 → 返回 412

  T5: 平板 B Pull，获取版本 11 的数据
      平板 B 本地版本 = 11
      但 pending 数据 "Song B" 被保留（本地胜出）

  T6: 平板 B 再次 Push "Song B"，带着 clientLibraryVersion = 11
      服务器: 11 == 11 → 接受
      服务器版本 = 12 ← 再次递增

---

## 2. 元数据同步详解

### 2.1 数据结构

#### 2.1.1 实体关系图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         实体关系                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Score (乐谱)                                                        │
│  ├── id (UUID)                                                       │
│  ├── title                                                           │
│  ├── composer                                                        │
│  ├── bpm                                                             │
│  ├── serverId (int, nullable)                                        │
│  ├── syncStatus ('pending' | 'synced' | 'pending_delete')           │
│  ├── version (int)                                                   │
│  ├── deletedAt (datetime, nullable)                                  │
│  └── updatedAt                                                       │
│       │                                                              │
│       │ 1:N                                                          │
│       ▼                                                              │
│  InstrumentScore (乐器分谱)                                          │
│  ├── id (UUID)                                                       │
│  ├── scoreId (FK → Score.id)                                        │
│  ├── instrumentType                                                  │
│  ├── customInstrument                                                │
│  ├── pdfHash (MD5, nullable) ─────────────────┐                     │
│  ├── pdfPath (本地路径)                        │                     │
│  ├── pdfSyncStatus ('pending'|'synced'|'needsDownload')             │
│  ├── serverId, syncStatus, version, deletedAt, updatedAt            │
│       │                                        │                     │
│       │ 1:N                                    │ 指向                 │
│       ▼                                        ▼                     │
│  Annotation (标注)                        PdfFile (概念)             │
│  ├── id (UUID)                            存储路径: {hash}.pdf       │
│  ├── instrumentScoreId (FK)               引用计数: N个InstrumentScore│
│  ├── pageNumber                                                      │
│  ├── annotationType                                                  │
│  ├── color, strokeWidth                                              │
│  ├── posX, posY                                                      │
│  └── serverId, syncStatus, version, updatedAt                       │
│                                                                      │
│  Setlist (曲单)                                                      │
│  ├── id (UUID)                                                       │
│  ├── name                                                            │
│  ├── description                                                     │
│  └── serverId, syncStatus, version, deletedAt, updatedAt            │
│       │                                                              │
│       │ M:N (通过 SetlistScore)                                      │
│       ▼                                                              │
│  SetlistScore (曲单-乐谱关联)                                        │
│  ├── setlistId (FK)                                                  │
│  ├── scoreId (FK)                                                    │
│  ├── orderIndex                                                      │
│  └── serverId, syncStatus, version, deletedAt, updatedAt            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 同步字段规范

每个需要同步的表都必须包含以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | TEXT | 本地生成的 UUID，客户端唯一标识 |
| `serverId` | INT? | 服务器端 ID，Push 成功后返回 |
| `syncStatus` | TEXT | `pending` / `synced`（见下方状态说明） |
| `version` | INT (64-bit) | 该记录的版本号，等于最后修改时的 libraryVersion |
| `updatedAt` | DATETIME? | 最后更新时间 |
| `deletedAt` | DATETIME? | 软删除时间戳，null 表示未删除 |

**syncStatus 状态说明：**

只使用两个状态，通过 `deletedAt` 区分操作类型：

| 状态 | deletedAt | 含义 |
|------|-----------|------|
| `pending` | NULL | 新建或修改，待同步 |
| `pending` | NOT NULL | 删除操作，待同步 |
| `synced` | NULL | 已同步，正常状态 |
| `synced` | NOT NULL | 已同步的删除记录（服务器软删除） |

**注意：** 不再使用 `pending_delete` 状态，统一用 `pending` + `deletedAt` 组合表示。

#### 2.1.3 全局同步状态表 (SyncState)

| Key | Value | 说明 |
|-----|-------|------|
| `libraryVersion` | "105" | 本地已同步到的版本号 |
| `lastSyncAt` | ISO8601 | 最后同步时间 |

#### 2.1.4 唯一性约束

| 实体 | 唯一键 | 客户端检查 |
|------|--------|-----------|
| Score | (title, composer, userId) | (title, composer) |
| InstrumentScore | (instrumentName, scoreId) | 同左 |
| Setlist | (name, userId) | (name) |
| SetlistScore | (setlistId, scoreId) | 同左 |
| Annotation | 无业务约束 | 通过 UUID 标识 |

**恢复规则：** 如果创建的实体与已删除实体的唯一键相同，视为"恢复"该实体（清除 deletedAt，不创建新记录）。

### 2.2 Push 逻辑详解

#### 2.2.1 Push 队列

```
┌─────────────────────────────────────────────────────────────────────┐
│  Push 队列结构                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  队列来源 (自动收集):                                                 │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 新建/修改:  WHERE syncStatus = 'pending' AND deletedAt IS NULL│    │
│  │ 删除:      WHERE syncStatus = 'pending_delete'              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  依赖排序:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 批次 1: Scores, Setlists                                     │    │
│  │         ↓ (需要先获得 serverId)                              │    │
│  │ 批次 2: InstrumentScores                                     │    │
│  │         ↓ (需要父 Score 的 serverId)                         │    │
│  │ 批次 3: Annotations                                          │    │
│  │         ↓ (需要父 InstrumentScore 的 serverId)               │    │
│  │ 批次 4: SetlistScores                                        │    │
│  │         (需要 Setlist 和 Score 的 serverId)                  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  跳过规则:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 如果父实体还没有 serverId → 跳过，等待下一轮同步              │    │
│  │ 例: 新 Score + 新 InstrumentScore 同时 pending               │    │
│  │     第一轮只推送 Score                                       │    │
│  │     第二轮推送 InstrumentScore (此时 Score 已有 serverId)    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 Push 请求格式

**请求端点：** `POST /library/push`

**请求体字段：**

| 字段 | 类型 | 说明 |
|------|------|------|
| clientLibraryVersion | int | 客户端当前版本号 |
| scores | array | Score 实体数组 |
| instrumentScores | array | InstrumentScore 实体数组（只含 pdfHash，不含文件） |
| annotations | array | Annotation 实体数组 |
| setlists | array | Setlist 实体数组 |
| setlistScores | array | SetlistScore 实体数组 |
| deletes | array | 待删除的实体标识，格式: `["score:456", "instrumentScore:789"]` |

**每个实体包含：**

| 字段 | 说明 |
|------|------|
| entityType | 实体类型 |
| entityId | 本地 UUID |
| serverId | 服务器 ID（更新时有值，创建时为 null） |
| operation | create / update |
| version | 版本号 |
| data | JSON 格式的业务数据 |
| localUpdatedAt | 本地更新时间 |

#### 2.2.3 Push 响应处理

**200 OK 响应字段：**

| 字段 | 说明 |
|------|------|
| newLibraryVersion | 新的全局版本号 |
| serverIdMapping | UUID → serverId 的映射表 |
| accepted | 成功处理的 UUID 列表 |
| rejected | 被拒绝的 UUID 列表 |

**200 OK 处理步骤：**
1. 保存 serverId 映射到本地实体
2. 更新 syncStatus = 'synced'
3. 更新本地 libraryVersion
4. 物理删除 pending_delete 记录

**412 Conflict 响应处理：**
1. 跳转到 Pull 阶段
2. 拉取缺失版本的变更
3. 合并数据
4. 使用新的 libraryVersion 重试 Push

### 2.3 Pull 逻辑详解

#### 2.3.1 Pull 请求

**请求端点：** `GET /library/pull?since={version}`

**响应字段：**

| 字段 | 说明 |
|------|------|
| libraryVersion | 最新版本号 |
| scores | Score 实体数组 |
| instrumentScores | InstrumentScore 实体数组（含 pdfHash） |
| annotations | Annotation 实体数组 |
| setlists | Setlist 实体数组 |
| setlistScores | SetlistScore 实体数组 |
| deleted | 已删除实体标识数组，格式: `["score:123", ...]` |

#### 2.3.2 Pull 处理流程

**处理步骤：**

1. 按 version 排序所有实体（确保删除→重建场景的正确顺序）

2. 遍历每个实体：
   - 如果实体已删除 → 同步远程的删除到本地
   - 如果本地不存在 → 创建新记录
   - 如果本地存在 → 调用合并逻辑

3. 处理删除列表：
   - 解析 deleteKey 获取 entityType 和 serverId
   - 查找本地对应记录
   - 如果本地 syncStatus = 'pending' → 断开 serverId 关联，保留本地修改
   - 否则 → 物理删除本地记录

4. 更新本地 libraryVersion

### 2.4 冲突解决详解

pending 包括 'pending' 和 'pending_delete'
只要本地有未同步的变更，就会覆盖服务器上其他设备的修改
  
两种表现形式
  | 变体         | 本地状态       | 服务器状态     | 结果               |
  |--------------|----------------|----------------|--------------------|
  | 修改 vs 修改 | pending (修改) | 其他设备的修改 | 本地修改覆盖服务器 |
  | 删除 vs 修改 | pending_delete | 其他设备的修改 | 本地删除覆盖服务器 |

#### 2.4.1 Merge 逻辑

```
┌─────────────────────────────────────────────────────────────────────┐
│  Merge 决策树                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  对于每个服务器返回的实体:                                            │
│                                                                      │
│                    ┌─────────────────┐                               │
│                    │ 服务器实体到达   │                               │
│                    └────────┬────────┘                               │
│                             │                                        │
│                             ▼                                        │
│                    ┌─────────────────┐                               │
│                    │ 本地存在记录？   │                               │
│                    └────────┬────────┘                               │
│                     │              │                                 │
│                    YES             NO                                │
│                     │              │                                 │
│                     ▼              ▼                                 │
│            ┌──────────────┐  ┌──────────────────┐                   │
│            │ 检查 syncStatus │  │ 创建新记录        │                   │
│            └───────┬──────┘  │ syncStatus=synced│                   │
│                    │         └──────────────────┘                   │
│         ┌──────────┴─────────┐                                       │
│         │                    │                                       │
│      pending              synced                                     │
│         │                    │                                       │
│         ▼                    ▼                                       │
│  ┌─────────────────┐  ┌─────────────────┐                           │
│  │ 本地优先         │  │ 服务器优先       │                           │
│  │ 跳过，不覆盖     │  │ 用服务器数据更新  │                           │
│  │ hadConflict=true│  │ syncStatus=synced│                           │
│  └─────────────────┘  └─────────────────┘                           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.4.2 删除冲突处理

| 场景 | 条件 | 处理方式 |
|------|------|---------|
| 服务器删除 + 本地已同步 | 服务器 deleted 列表包含实体，本地 syncStatus='synced' | 物理删除本地记录 |
| 服务器删除 + 本地有修改 | 服务器 deleted 列表包含实体，本地 syncStatus='pending' | 保留本地修改，serverId = null（断开关联），下次 Push 作为新记录创建 |
| 本地删除 + 服务器有更新 | 本地 syncStatus='pending_delete' | 删除优先，Push 时发送删除请求 |

### 2.5 本地操作处理

#### 2.5.1 创建实体

**创建 Score 的处理逻辑：**

1. 检查是否有已删除的同名记录（恢复场景）
2. 如果存在已删除记录 → 恢复该记录：清除 deletedAt，设置 syncStatus = 'pending'
3. 否则 → 插入新记录：生成 UUID，syncStatus = 'pending'，serverId = null
4. 触发同步（防抖 5s）

#### 2.5.2 删除实体

**删除 InstrumentScore 的处理逻辑：**

1. 级联删除关联的 Annotations（物理删除，不同步）
2. 判断删除方式：
   - 如果有 serverId（已同步到服务器）→ 软删除：设置 deletedAt 和 syncStatus = 'pending_delete'
   - 如果无 serverId（从未同步）→ 直接物理删除
3. 检查 PDF 引用计数，必要时删除本地 PDF 文件（详见 §3.5）
4. 触发同步

---

## 3. PDF 文件同步详解

### 3.1 PDF 存储架构

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF 存储架构 (基于 Hash 的内容寻址 - 全局去重)                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  设计理念:                                                            │
│  • 相同内容的 PDF 在全局只存一份（跨用户去重）                          │
│  • 文件名 = MD5 Hash，与用户无关                                      │
│  • InstrumentScore 通过 pdfHash 引用文件                             │
│  • 上传前检查全局是否已有该 Hash，有则直接引用（秒传）                   │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  客户端本地存储:                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  /documents/pdfs/                                            │    │
│  │  ├── abc123def456.pdf     ← Hash 作为文件名                  │    │
│  │  ├── 789xyz000111.pdf                                        │    │
│  │  └── ...                                                     │    │
│  │                                                              │    │
│  │  InstrumentScore 表:                                         │    │
│  │  ┌────────────────────────────────────────────────────────┐ │    │
│  │  │ id       │ pdfHash          │ pdfPath                  │ │    │
│  │  │ uuid-1   │ abc123def456     │ /documents/pdfs/abc...pdf│ │    │
│  │  │ uuid-2   │ abc123def456     │ /documents/pdfs/abc...pdf│ ← 共享│
│  │  │ uuid-3   │ 789xyz000111     │ /documents/pdfs/789...pdf│ │    │
│  │  └────────────────────────────────────────────────────────┘ │    │
│  │                                                              │    │
│  │  本地引用计数 = COUNT(InstrumentScore WHERE pdfHash = ?)    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  服务器全局存储:                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  /uploads/global/pdfs/           ← 全局目录，不分用户         │    │
│  │  ├── abc123def456.pdf                                        │    │
│  │  ├── 789xyz000111.pdf                                        │    │
│  │  └── ...                                                     │    │
│  │                                                              │    │
│  │  PdfFile 表 (可选，用于管理):                                 │    │
│  │  ┌────────────────────────────────────────────────────────┐ │    │
│  │  │ hash (PK)        │ storagePath              │ size     │ │    │
│  │  │ abc123def456     │ /global/pdfs/abc...pdf   │ 2.5MB    │ │    │
│  │  │ 789xyz000111     │ /global/pdfs/789...pdf   │ 1.2MB    │ │    │
│  │  └────────────────────────────────────────────────────────┘ │    │
│  │                                                              │    │
│  │  全局引用计数:                                                │    │
│  │  SELECT COUNT(*) FROM instrument_scores                      │    │
│  │  WHERE pdf_hash = ? AND deleted_at IS NULL                   │    │
│  │  (跨所有用户统计)                                             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  示例场景:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 用户 A 上传 "贝多芬第九交响曲.pdf" (hash: abc123)             │    │
│  │   → 服务器存储文件，hash=abc123                              │    │
│  │                                                              │    │
│  │ 用户 B 上传相同文件 (hash: abc123)                            │    │
│  │   → 秒传: 服务器已有此 hash，直接引用，无需传输               │    │
│  │   → 用户 B 的 InstrumentScore.pdfHash = abc123               │    │
│  │                                                              │    │
│  │ 用户 A 删除该分谱                                             │    │
│  │   → 检查全局引用计数: 用户 B 还在引用                         │    │
│  │   → PDF 文件保留                                             │    │
│  │                                                              │    │
│  │ 用户 B 也删除该分谱                                           │    │
│  │   → 检查全局引用计数: 0                                       │    │
│  │   → PDF 文件物理删除                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 PDF 同步状态

InstrumentScore 表中的 `pdfSyncStatus` 字段：

| 状态 | 含义 | 触发条件 |
|------|------|---------|
| `pending` | PDF 待上传 | 本地新增 PDF，尚未上传到服务器 |
| `synced` | PDF 已同步 | 上传成功 或 本地 Hash 与服务器一致 |
| `needsDownload` | 需要下载 | Pull 时发现服务器有新 Hash，本地没有 |

### 3.3 Upload 逻辑详解

#### 3.3.1 Upload 队列

**队列来源查询条件：**
- pdfSyncStatus = 'pending'
- serverId IS NOT NULL（元数据已同步）
- pdfPath IS NOT NULL（有本地文件）

**处理顺序：** 串行处理，避免占用过多带宽

**优先级（可选）：**
1. 用户正在查看的分谱
2. 最近创建的
3. 其他

#### 3.3.2 Upload 流程

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF Upload 流程                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────┐                                                 │
│  │ 1. 读取本地 PDF  │                                                 │
│  └────────┬────────┘                                                 │
│           │                                                          │
│           ▼                                                          │
│  ┌─────────────────────┐                                             │
│  │ 2. 计算 MD5 Hash    │                                             │
│  │    hash = md5(bytes)│                                             │
│  └────────┬────────────┘                                             │
│           │                                                          │
│           ▼                                                          │
│  ┌────────────────────────────────────┐                              │
│  │ 3. 秒传检测                         │                              │
│  │    GET /file/checkHash?hash=abc123 │                              │
│  └────────┬────────────────┬──────────┘                              │
│           │                │                                         │
│        存在              不存在                                       │
│           │                │                                         │
│           ▼                ▼                                         │
│  ┌─────────────┐  ┌──────────────────────┐                          │
│  │ 4a. 秒传成功 │  │ 4b. 上传文件          │                          │
│  │ 跳过上传    │  │ POST /file/upload     │                          │
│  └──────┬──────┘  └──────────┬───────────┘                          │
│         │                    │                                       │
│         └────────────────────┘                                       │
│                    │                                                 │
│                    ▼                                                 │
│  ┌─────────────────────────────────────────┐                        │
│  │ 5. 更新本地数据库                         │                        │
│  │    pdfSyncStatus = 'synced'             │                        │
│  │    pdfHash = 'abc123'                   │                        │
│  └─────────────────────────────────────────┘                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.3.3 秒传机制（全局去重）

**上传 PDF 的处理逻辑：**

1. 读取本地 PDF 文件内容
2. 计算 MD5 Hash
3. 调用 `GET /file/checkHash?hash={hash}` 检查服务器全局是否已有此 Hash（跨所有用户）
4. 如果存在：
   - 秒传成功，无需上传文件
   - 调用 API 将 InstrumentScore 的 pdfHash 指向该文件
5. 如果不存在：
   - 首次上传该文件到全局存储
   - 调用 `POST /file/upload` 上传文件
6. 更新本地 pdfSyncStatus = 'synced'，pdfHash = 计算的 hash 值

**服务器端 checkHash 实现方式：**
- 方案 1：查询 PdfFile 表是否存在该 hash
- 方案 2：直接检查文件系统 `/uploads/global/pdfs/{hash}.pdf` 是否存在

### 3.4 Download 逻辑详解

#### 3.4.1 Download 队列

**队列来源查询条件：**
- pdfSyncStatus = 'needsDownload'

**触发时机：**
1. Pull 时发现新的 pdfHash
2. 用户打开分谱时（按需下载）
3. 后台批量下载（可选，WiFi 环境）

**优先级：**
1. 用户正在请求查看的 → 立即下载，显示进度
2. 后台队列 → 串行下载

#### 3.4.2 Download 流程

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF Download 流程                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌───────────────────────┐                                           │
│  │ 1. 检查本地是否已有    │                                           │
│  │    Hash 对应的文件     │                                           │
│  └───────────┬───────────┘                                           │
│              │                                                       │
│       ┌──────┴──────┐                                                │
│       │             │                                                │
│    已存在         不存在                                              │
│       │             │                                                │
│       ▼             ▼                                                │
│  ┌─────────┐  ┌─────────────────────────┐                           │
│  │ 复用文件 │  │ 2. 从服务器下载          │                           │
│  │ 更新路径 │  │ GET /file/download/{hash}│                           │
│  └────┬────┘  └───────────┬─────────────┘                           │
│       │                   │                                          │
│       │                   ▼                                          │
│       │           ┌───────────────────────┐                         │
│       │           │ 3. 验证 Hash           │                         │
│       │           │ if md5(bytes) != hash │                         │
│       │           │   throw CorruptError   │                         │
│       │           └───────────┬───────────┘                         │
│       │                       │                                      │
│       │                       ▼                                      │
│       │           ┌─────────────────────────────┐                   │
│       │           │ 4. 保存到本地                │                   │
│       │           │ path = /pdfs/{hash}.pdf     │                   │
│       │           └───────────┬─────────────────┘                   │
│       │                       │                                      │
│       └───────────────────────┤                                      │
│                               ▼                                      │
│               ┌─────────────────────────────────────┐               │
│               │ 5. 更新数据库                        │               │
│               │    pdfPath = '/pdfs/{hash}.pdf'     │               │
│               │    pdfSyncStatus = 'synced'         │               │
│               └─────────────────────────────────────┘               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.4.3 按需下载 (懒加载)

**用户打开分谱时的处理逻辑：**

1. 检查本地文件是否存在且 Hash 匹配
   - 如果匹配 → 直接使用本地文件

2. 检查是否有其他 InstrumentScore 已下载了相同 Hash 的文件
   - 如果存在 → 复用已下载的文件，更新当前记录的 pdfPath

3. 如果以上都不满足 → 从服务器下载

### 3.5 引用计数与删除

#### 3.5.1 引用计数逻辑（全局）

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF 引用计数 (全局跨用户)                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  全局引用计数 = 所有用户中使用相同 pdfHash 的 InstrumentScore 数量     │
│                                                                      │
│  服务器端查询:                                                        │
│  SELECT COUNT(*) FROM instrument_scores                              │
│  WHERE pdf_hash = 'abc123'                                           │
│    AND deleted_at IS NULL                                            │
│  -- 注意: 不限制 user_id，跨所有用户统计                              │
│                                                                      │
│  客户端本地查询 (只统计本地):                                         │
│  SELECT COUNT(*) FROM instrument_scores                              │
│  WHERE pdfHash = 'abc123'                                            │
│    AND deletedAt IS NULL                                             │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  示例 (跨用户场景):                                                   │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ pdfHash = 'abc123' (贝多芬第九交响曲.pdf)                       │ │
│  │                                                                 │ │
│  │ 用户 A:                                                         │ │
│  │   InstrumentScore A1 (Piano)  ──┐                               │ │
│  │   InstrumentScore A2 (Violin) ──┤                               │ │
│  │                                  │                               │ │
│  │ 用户 B:                          ├─→ 全局引用计数 = 4            │ │
│  │   InstrumentScore B1 (Full)   ──┤                               │ │
│  │                                  │                               │ │
│  │ 用户 C:                          │                               │ │
│  │   InstrumentScore C1 (Cello)  ──┘                               │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  用户 A 删除 A1 和 A2:                                               │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ 全局引用计数 4 → 2 (用户 B 和 C 还在引用)                        │ │
│  │ 服务器 PDF 文件保留                                             │ │
│  │ 用户 A 本地：引用计数 0，删除本地 PDF 副本                       │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  所有用户都删除后:                                                    │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ 全局引用计数 → 0                                                │ │
│  │ 服务器物理删除 /global/pdfs/abc123.pdf                          │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.5.2 客户端删除流程

**删除 InstrumentScore 时的 PDF 处理逻辑：**

1. 获取要删除的 InstrumentScore 的 pdfHash
2. 计算删除后的本地引用计数（排除当前记录，排除已删除的记录）
3. 如果本地引用计数 = 0 → 删除本地 PDF 文件
4. 服务器端会单独处理全局引用计数

#### 3.5.3 服务器端删除逻辑（全局引用计数）

**当收到删除 InstrumentScore 的请求时：**

1. 获取要删除的 InstrumentScore 的 pdfHash
2. 计算全局引用计数（跨所有用户）：
   - 查询条件：pdf_hash = ? AND id != ? AND deleted_at IS NULL
   - 注意：不限制 user_id
3. 如果 count = 0：
   - 没有任何用户在引用该 PDF
   - 物理删除文件：`/uploads/global/pdfs/{hash}.pdf`
   - 删除 PdfFile 表记录（如果有）
4. 如果 count > 0：
   - 还有其他用户（或本用户其他分谱）在引用
   - 保留 PDF 文件，只删除 InstrumentScore 记录

### 3.6 冲突处理

| 场景 | 条件 | 处理方式 |
|------|------|---------|
| 本地和服务器的 pdfHash 不同 | 本地 pdfSyncStatus = 'pending' | **本地优先**：保留本地 pdfHash，上传本地 PDF，服务器更新 pdfHash |
| 本地已同步，服务器更新了 pdfHash | 本地 pdfSyncStatus = 'synced' | **服务器优先**：更新本地 pdfHash，设置 pdfSyncStatus = 'needsDownload'，下载新 PDF，检查旧 Hash 引用计数 |
| 相同 Hash | 内容相同 | **无冲突**：相同 Hash 意味着相同内容 |

### 3.7 UI 状态显示

```
┌─────────────────────────────────────────────────────────────────────┐
│  Settings → Cloud Sync 页面显示                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  同步状态:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ ☁️ Cloud Sync                                                │    │
│  │                                                              │    │
│  │ 元数据: ✓ 已同步 (version 105)                               │    │
│  │ 上次同步: 2 分钟前                                           │    │
│  │                                                              │    │
│  │ PDF 文件:                                                    │    │
│  │ ├─ 待上传: 3 个文件 (15.2 MB)                                │    │
│  │ ├─ 待下载: 1 个文件 (2.1 MB)                                 │    │
│  │ └─ 正在上传: Symphony_No5.pdf (45%)                          │    │
│  │                                                              │    │
│  │ [立即同步]                                                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  存储使用:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 本地: 256 MB                                                 │    │
│  │ 云端: 245 MB (已去重)                                        │    │
│  │ 配额: 1 GB                                                   │    │
│  │ ████████░░░░░░░░░░░░ 24.5%                                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 附录

### A. 错误处理策略

| 错误类型 | 处理方式 |
|---------|---------|
| 网络超时 | 重试 3 次，指数退避 (5s, 15s, 45s) |
| 401 Unauthorized | 跳转登录页面 |
| 412 Conflict | Pull → Merge → 重试 Push |
| 413 Payload Too Large | 提示用户 PDF 文件过大 |
| 500 Server Error | 30 秒后重试 |
| PDF 下载失败 | 保持 needsDownload 状态，下次重试 |
| PDF Hash 不匹配 | 重新下载 |

### B. 性能优化

1. **批量操作**: Push/Pull 使用批量 API，减少请求次数
2. **防抖**: 本地操作后 5 秒内的变更合并为一次同步
3. **串行 PDF**: PDF 上传/下载串行执行，避免带宽竞争
4. **按需加载**: Annotations 和 PDF 按需加载，首次同步快
5. **Hash 去重**: 相同内容只存一份，节省存储和带宽

### C. 日志记录

关键操作日志格式：

| 阶段 | 日志示例 |
|------|---------|
| 同步开始 | `[LibrarySyncService] === SYNC START ===` |
| Push | `[LibrarySyncService] Push: scores=2, instrumentScores=1, deletes=0` |
| Pull | `[LibrarySyncService] Pull: pulled=5, conflicts=1` |
| PDF 同步 | `[LibrarySyncService] PDF: uploaded=1, downloaded=0, skipped(秒传)=1` |
| 同步完成 | `[LibrarySyncService] === SYNC COMPLETE: 1523ms ===` |
