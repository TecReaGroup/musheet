# MuSheet App 端完整同步逻辑

本文档描述 MuSheet Flutter App 的完整同步架构，采用**元数据通道**与**文件通道**完全分离的设计。

---

## 目录

1. [总体同步逻辑](#1-总体同步逻辑)
2. [元数据同步详解](#2-元数据同步详解)
3. [PDF 文件同步详解](#3-pdf-文件同步详解)

---

## 1. 总体同步逻辑

### 1.1 核心架构原则

```
┌─────────────────────────────────────────────────────────────────────┐
│                        MuSheet 同步架构                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ┌──────────────┐         ┌──────────────┐                         │
│   │   元数据通道   │         │   文件通道    │                         │
│   │  (Metadata)  │         │    (PDF)     │                         │
│   ├──────────────┤         ├──────────────┤                         │
│   │ Score        │         │              │                         │
│   │ InstrumentScore ───────┼─→ pdfHash ───┼─→ PDF 文件               │
│   │ Setlist      │         │              │                         │
│   │ SetlistScore │         │ 引用计数管理   │                         │
│   └──────────────┘         └──────────────┘                         │
│                                                                      │
│   注: Annotation 不作为独立同步实体，嵌入 InstrumentScore.annotationsJson │
│         │                         │                                  │
│         ▼                         ▼                                  │
│   libraryVersion            pdfHash (MD5)                           │
│   (全局版本号)               (内容寻址)                               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**设计原则：**

| 原则 | 说明 |
|------|------|
| **UI 读写本地** | 所有操作立即写入本地 SQLite，UI 永不等待网络 |
| **Push 先于 Pull** | 铁律：总是先推送本地变更，再拉取服务器数据 |
| **本地优先** | 冲突时，pending 状态的本地数据优先保留（如果是 synced 则服务器优先） |
| **双通道分离** | 元数据和 PDF 使用独立的同步队列和版本控制 |
| **PDF 引用计数** | 相同内容的 PDF 只存一份，通过 Hash 引用 |

### 1.2 同步状态机

```
                         ┌─────────────────────────────┐
                         │                             │
                         ▼                             │
    ┌───────┐   数据变更(5s防抖)   ┌─────────┐  success │
    │ idle  │ ──────────────────► │ syncing │ ─────────┘
    └───────┘                     └─────────┘
        ▲                              │
        │ network restored             │ error / 412 conflict
        │                              ▼
    ┌────────┐                    ┌─────────┐
    │ paused │ ◄── no network ─── │  error  │
    └────────┘                    └─────────┘
        │                              │
        │                              │ retry(30s)
        └──────────────────────────────┘
```

**状态说明：**

| 状态 | 含义 |
|------|------|
| idle | 空闲，等待下一次触发 |
| syncing | 正在同步（Push → Pull → PDF） |
| paused | 无网络，暂停同步，本地操作继续 |
| error | 同步出错，30 秒后自动重试 |

**同步阶段（syncing 内部）：**

```
syncing
  ├─► pushing     (推送本地变更)
  │     │
  │     ├─► 412 Conflict ─► pulling ─► merging ─► pushing (重试)
  │     │
  │     └─► success
  │
  ├─► pulling     (拉取服务器变更)
  │
  ├─► merging     (合并数据)
  │
  └─► pdfSyncing  (PDF 文件同步，独立队列)
```

### 1.3 触发机制

采用**极简触发策略**：统一 5 秒防抖，仅区分网络状态和登录事件。

```
┌─────────────────────────────────────────────────────────────────────┐
│                        触发机制状态图                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│                    ┌──────────────┐                                 │
│                    │   有网络      │                                 │
│                    │  (正常模式)   │                                 │
│                    └──────┬───────┘                                 │
│                           │                                          │
│         ┌─────────────────┼─────────────────┐                       │
│         │                 │                 │                       │
│         ▼                 ▼                 ▼                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐             │
│  │ 本地数据变更 │  │  用户登录    │  │ 网络恢复        │             │
│  │ (任何操作)   │  │             │  │ (从无网→有网)   │             │
│  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘             │
│         │                 │                  │                       │
│         ▼                 ▼                  ▼                       │
│   ┌──────────┐     ┌──────────┐       ┌──────────┐                  │
│   │ 防抖 5s  │     │ 立即同步 │       │ 立即同步 │                  │
│   │ 后同步   │     │ (全量)   │       │ (增量)   │                  │
│   └──────────┘     └──────────┘       └──────────┘                  │
│                                                                      │
│                    ┌──────────────┐                                 │
│                    │   无网络      │                                 │
│                    │  (暂停模式)   │                                 │
│                    └──────┬───────┘                                 │
│                           │                                          │
│                           ▼                                          │
│                    ┌──────────────┐                                 │
│                    │ 本地正常操作  │                                 │
│                    │ 标记 pending  │                                 │
│                    │ 不触发同步    │                                 │
│                    └──────────────┘                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

| 触发条件 | 动作 | 说明 |
|---------|------|------|
| **本地数据变更** | 防抖 5s 后同步 | 统一入口：增删改查、App 启动、后台恢复等都走这里 |
| **网络恢复** | 立即同步 | 从无网络恢复到有网络时，跳过防抖立即同步 |
| **用户登录** | 立即全量同步 | Push 本地 pending 数据 → Pull 服务器数据 |
| **用户登出** | 停止同步 + 清空本地 | 清除所有本地数据 |
| **无网络** | 暂停同步 | 本地操作正常，标记 pending，不发起网络请求 |

**设计理念：**

1. **统一入口**: 所有触发条件最终都汇聚到一个同步入口，通过 5 秒防抖合并
2. **网络感知**: 无网络时自动暂停，有网络时自动恢复
3. **最小化触发点**: 只有 3 种需要特殊处理的情况（数据变更、网络恢复、登录）

**实现示例：**

```dart
class SyncTriggerService {
  Timer? _debounceTimer;
  bool _hasNetwork = true;

  /// 统一触发入口 - 所有数据变更都调用这个方法
  void requestSync({bool immediate = false}) {
    if (!_hasNetwork) return;  // 无网络时不触发

    if (immediate) {
      _performSync();
      return;
    }

    // 5 秒防抖
    _debounceTimer?.cancel();
    _debounceTimer = Timer(Duration(seconds: 5), _performSync);
  }

  void init() {
    // 监听网络状态
    Connectivity().onConnectivityChanged.listen((status) {
      _hasNetwork = status != ConnectivityResult.none;
      if (_hasNetwork) {
        requestSync(immediate: true);  // 网络恢复，立即同步
      }
    });
  }
}
```

### 1.4 完整同步流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        完整同步周期                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 1: PUSH 元数据                                            ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  1. 收集待同步数据:                                              ║ │
│  ║     ┌─────────────────────────────────────────────────┐        ║ │
│  ║     │ syncStatus = 'pending'       → 新建/修改的记录   │        ║ │
│  ║     │ syncStatus = 'pending' + deletedAt → 待删除的记录│        ║ │
│  ║     └─────────────────────────────────────────────────┘        ║ │
│  ║                                                                 ║ │
│  ║  2. 按依赖顺序排序:                                              ║ │
│  ║     ┌────────────────────────────────────────────────┐         ║ │
│  ║     │ 第1批: Scores, Setlists (无依赖)                │         ║ │
│  ║     │ 第2批: InstrumentScores (依赖 Score)           │         ║ │
│  ║     │ 第3批: SetlistScores (依赖 Setlist + Score)    │         ║ │
│  ║     └────────────────────────────────────────────────┘         ║ │
│  ║                                                                 ║ │
│  ║  3. 发送请求: POST /library/push                                ║ │
│  ║     请求体包含 clientLibraryVersion 和各实体数组                 ║ │
│  ║     instrumentScores 只含 pdfHash，不含实际文件                  ║ │
│  ║                                                                 ║ │
│  ║  4. 处理响应:                                                    ║ │
│  ║     ┌─────────────────────────────────────────────────────┐    ║ │
│  ║     │ 200 OK:                                              │    ║ │
│  ║     │   • 保存 serverId 映射                               │    ║ │
│  ║     │   • 更新 syncStatus = 'synced'                      │    ║ │
│  ║     │   • 更新本地 libraryVersion                          │    ║ │
│  ║     │   • 物理删除已同步的删除记录                        │    ║ │
│  ║     ├─────────────────────────────────────────────────────┤    ║ │
│  ║     │ 412 Conflict:                                        │    ║ │
│  ║     │   • 跳到阶段 2 拉取数据                              │    ║ │
│  ║     │   • 合并后重试 Push                                  │    ║ │
│  ║     └─────────────────────────────────────────────────────┘    ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                │                                     │
│                                ▼                                     │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 2: PULL 元数据                                            ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  1. 请求增量数据: GET /library/pull?since={version}             ║ │
│  ║                                                                 ║ │
│  ║  2. 响应包含:                                                    ║ │
│  ║     • libraryVersion (最新版本号)                               ║ │
│  ║     • 各实体数组 (scores, instrumentScores 含 pdfHash+annotationsJson, etc.) ║ │
│  ║     • deleted 数组 (已删除实体的标识)                            ║ │
│  ║                                                                 ║ │
│  ║  3. 合并策略 (详见 §2.4):                                        ║ │
│  ║     • 本地 pending → 保留本地                                    ║ │
│  ║     • 本地 synced  → 使用服务器数据                              ║ │
│  ║     • 本地不存在   → 创建新记录                                  ║ │
│  ║                                                                 ║ │
│  ║  4. 更新本地 libraryVersion                                     ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                │                                     │
│                                ▼                                     │
│  ╔════════════════════════════════════════════════════════════════╗ │
│  ║  阶段 3: PDF 文件同步 (独立队列)                                  ║ │
│  ╠════════════════════════════════════════════════════════════════╣ │
│  ║                                                                 ║ │
│  ║  在元数据 Push 成功后立即开始 PDF 上传                           ║ │
│  ║  详见 §3                                                        ║ │
│  ║                                                                 ║ │
│  ║  1. 上传队列: pdfSyncStatus = 'pending' AND pdfHash IS NOT NULL ║ │
│  ║     (PDF 通过 hash 上传，不依赖元数据的 serverId)                ║ │
│  ║  2. 下载队列: pdfSyncStatus = 'needsDownload'                   ║ │
│  ║  3. 引用计数: 基于 pdfHash 管理文件生命周期                       ║ │
│  ║                                                                 ║ │
│  ╚════════════════════════════════════════════════════════════════╝ │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.5 特殊场景

#### 1.5.1 新设备登录（全量同步）

```
┌─────────────────────────────────────────────────────────────────────┐
│  新设备登录流程                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 用户登录成功                                                      │
│     │                                                                │
│     ▼                                                                │
│  2. 初始化本地数据库（如有离线数据则保留）                             │
│     libraryVersion = 0                                               │
│     │                                                                │
│     ▼                                                                │
│  3. Push 本地 pending 数据（遵循 Push 先于 Pull 铁律）                │
│     ┌─────────────────────────────────────────────┐                 │
│     │ 场景: 用户未登录时创建的本地数据              │                 │
│     │ 如果没有 pending 数据则跳过此步               │                 │
│     └─────────────────────────────────────────────┘                 │
│     │                                                                │
│     ▼                                                                │
│  4. Pull 全量元数据 (since = 0)                                      │
│     ┌─────────────────────────────────────────────┐                 │
│     │ 服务器返回所有: Scores, InstrumentScores,    │                 │
│     │ Setlists, SetlistScores                     │                 │
│     │ (不包含独立 Annotations，标注嵌入 InstrumentScore) │                 │
│     └─────────────────────────────────────────────┘                 │
│     │                                                                │
│     ▼                                                                │
│  5. UI 立即可用                                                       │
│     用户可以看到曲库列表、曲单列表                                     │
│     │                                                                │
│     ▼                                                                │
│  6. PDF 按需下载                                                      │
│     用户打开某个分谱时才下载对应 PDF                                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.2 网络中断处理

```
┌─────────────────────────────────────────────────────────────────────┐
│  网络中断场景                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  同步过程中网络断开:                                                  │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 停止当前同步                                               │    │
│  │ • 状态 → waitingForNetwork                                  │    │
│  │ • 已成功的部分保留（不回滚）                                  │    │
│  │ • 未完成的部分等待重试                                       │    │
│  │ • 监听网络状态，恢复后立即重试                                │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  离线操作:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 所有操作正常写入本地数据库                                  │    │
│  │ • syncStatus = 'pending'                                    │    │
│  │ • UI 正常响应                                                │    │
│  │ • 网络恢复后自动同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  PDF 传输中断:                                                        │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 中止传输，标记失败                                         │    │
│  │ • 不支持断点续传（PDF 通常 1-10MB，重传成本可接受）           │    │
│  │ • 网络恢复后从头开始                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.3 用户登出

```
┌─────────────────────────────────────────────────────────────────────┐
│  用户登出流程                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 用户点击登出                                                      │
│     │                                                                │
│     ▼                                                                │
│  2. 检查是否有未同步数据                                              │
│     ├─ 有 → 提示用户 "有未同步的数据，确定登出？"                     │
│     │       ├─ 确定 → 继续                                           │
│     │       └─ 取消 → 返回                                           │
│     └─ 无 → 继续                                                     │
│     │                                                                │
│     ▼                                                                │
│  3. 停止同步服务                                                      │
│     │                                                                │
│     ▼                                                                │
│  4. 清空本地数据                                                      │
│     • 删除所有数据库表内容                                            │
│     • 删除所有本地 PDF 文件                                           │
│     • libraryVersion = 0                                             │
│     │                                                                │
│     ▼                                                                │
│  5. 返回登录页面                                                      │
│                                                                      │
│  注: 不支持切换账号，必须先登出再登录                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.4 未登录状态使用

```
┌─────────────────────────────────────────────────────────────────────┐
│  未登录状态使用流程                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  用户可以在未登录状态下使用 App:                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 创建/编辑/删除 Score、InstrumentScore、Setlist 等          │    │
│  │ • 所有操作写入本地数据库，syncStatus = 'pending'             │    │
│  │ • PDF 文件保存到本地，pdfSyncStatus = 'pending'              │    │
│  │ • 无网络请求，完全离线使用                                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  首次登录时:                                                          │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 遵循 Push 先于 Pull 铁律                                   │    │
│  │ • 先 Push 本地 pending 数据到服务器                          │    │
│  │ • 再 Pull 服务器数据（如果该账号之前有数据）                  │    │
│  │ • 合并后完成同步                                             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.5.5 App 退出

```
┌─────────────────────────────────────────────────────────────────────┐
│  App 退出处理                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  正常退出:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • 所有本地数据已持久化到 SQLite                              │    │
│  │ • 未同步的数据保留 (syncStatus = 'pending')                  │    │
│  │ • 下次启动时自动同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  强制退出/崩溃:                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ • SQLite 事务保证数据一致性                                  │    │
│  │ • 可能丢失当前正在进行的同步状态                              │    │
│  │ • 下次启动时重新同步                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.6 冲突解决总览

```
┌─────────────────────────────────────────────────────────────────────┐
│  冲突解决策略                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  版本冲突 (412 Conflict):                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 场景: 设备 A 和 B 都在 version=100，A 先提交成功              │    │
│  │       B 提交时服务器返回 412                                  │    │
│  │                                                              │    │
│  │ 处理: B 先 Pull → 合并 → 重试 Push                           │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  数据冲突:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 本地 syncStatus = 'pending' → 本地优先，保留本地修改          │    │
│  │ 本地 syncStatus = 'synced'  → 服务器优先，覆盖本地            │    │
│  │ (无论是修改还是删除，都遵循上述 pending/synced 规则)          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  PDF 冲突:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 基于 Hash 的内容寻址，不存在内容冲突                          │    │
│  │ 相同 Hash = 相同文件，无需处理                                │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

冲突解决样例：

T1: 服务器版本 = 10
      ├── 手机 A 本地版本 = 10
      └── 平板 B 本地版本 = 10

  T2: 手机 A Push "Song A" 成功
      服务器版本 = 11 ← 服务器递增
      手机 A 本地版本 = 11 ← 同步后更新

  T3: 平板 B 修改 "Song B"（本地版本仍 = 10，因为还没同步）

  T4: 平板 B Push，带着 clientLibraryVersion = 10
      服务器: 10 < 11 → 返回 412

  T5: 平板 B Pull，获取版本 11 的数据
      平板 B 本地版本 = 11
      但 pending 数据 "Song B" 被保留（本地胜出）

  T6: 平板 B 再次 Push "Song B"，带着 clientLibraryVersion = 11
      服务器: 11 == 11 → 接受
      服务器版本 = 12 ← 再次递增

---

## 2. 元数据同步详解

### 2.1 数据结构

#### 2.1.1 实体关系图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         实体关系                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Score (乐谱)                                                        │
│  ├── id (UUID)                                                       │
│  ├── title                                                           │
│  ├── composer                                                        │
│  ├── bpm                                                             │
│  ├── serverId (int, nullable)                                        │
│  ├── syncStatus ('pending' | 'synced')                                 │
│  ├── version (int)                                                   │
│  ├── deletedAt (datetime, nullable)                                  │
│  └── updatedAt                                                       │
│       │                                                              │
│       │ 1:N                                                          │
│       ▼                                                              │
│  InstrumentScore (乐器分谱)                                          │
│  ├── id (UUID)                                                       │
│  ├── scoreId (FK → Score.id)                                        │
│  ├── instrumentType                                                  │
│  ├── customInstrument                                                │
│  ├── pdfHash (MD5, nullable) ─────────────────┐                     │
│  ├── pdfPath (本地路径)                        │                     │
│  ├── pdfSyncStatus ('pending'|'synced'|'needsDownload')             │
│  ├── annotationsJson (TEXT) ← 嵌入的标注数据    │                     │
│  ├── serverId, syncStatus, version, deletedAt, updatedAt            │
│                                                │                     │
│                                                │ 指向                 │
│                                                ▼                     │
│                                           PdfFile (概念)             │
│                                           存储路径: {hash}.pdf       │
│                                           引用计数: N个InstrumentScore│
│                                                                      │
│  Annotation (标注) - 仅本地缓存表，不参与同步                         │
│  ├── id (UUID)                                                       │
│  ├── instrumentScoreId (FK)                                          │
│  ├── pageNumber, annotationType, color, strokeWidth, posX, posY     │
│  └── 无同步字段 (无 serverId, syncStatus, version)                   │
│                                                                      │
│  Setlist (曲单)                                                      │
│  ├── id (UUID)                                                       │
│  ├── name                                                            │
│  ├── description                                                     │
│  └── serverId, syncStatus, version, deletedAt, updatedAt            │
│       │                                                              │
│       │ M:N (通过 SetlistScore)                                      │
│       ▼                                                              │
│  SetlistScore (曲单-乐谱关联)                                        │
│  ├── setlistId (FK)                                                  │
│  ├── scoreId (FK)                                                    │
│  ├── orderIndex                                                      │
│  └── serverId, syncStatus, version, deletedAt, updatedAt            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 同步字段规范

每个需要同步的表都必须包含以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | TEXT | 本地生成的 UUID，客户端唯一标识 |
| `serverId` | INT? | 服务器端 ID，Push 成功后返回 |
| `syncStatus` | TEXT | `pending` / `synced`（见下方状态说明） |
| `version` | INT (64-bit) | 该记录的版本号，等于最后修改时的 libraryVersion |
| `updatedAt` | DATETIME? | 最后更新时间 |
| `deletedAt` | DATETIME? | 软删除时间戳，null 表示未删除 |

**syncStatus 状态说明：**

只使用两个状态，通过 `deletedAt` 区分操作类型：

| 状态 | deletedAt | 含义 |
|------|-----------|------|
| `pending` | NULL | 新建或修改，待同步 |
| `pending` | NOT NULL | 删除操作，待同步 |
| `synced` | NULL | 已同步，正常状态 |
| `synced` | NOT NULL | 已同步的删除记录（服务器软删除） |

**注意：** 不再使用 `pending_delete` 状态，统一用 `pending` + `deletedAt` 组合表示。

#### 2.1.3 全局同步状态表 (SyncState)

| Key | Value | 说明 |
|-----|-------|------|
| `libraryVersion` | "105" | 本地已同步到的版本号 |
| `lastSyncAt` | ISO8601 | 最后同步时间 |

#### 2.1.4 唯一性约束

| 实体 | 唯一键 | 客户端检查 |
|------|--------|-----------|
| Score | (title, composer, userId) | (title, composer) |
| InstrumentScore | (instrumentName, scoreId) | 同左 |
| Setlist | (name, userId) | (name) |
| SetlistScore | (setlistId, scoreId) | 同左 |

**注意：** Annotation 不参与同步，无唯一性约束要求。

**恢复规则：** 如果创建的实体与已删除实体的唯一键相同，视为"恢复"该实体（清除 deletedAt，不创建新记录）。

### 2.2 Push 逻辑详解

#### 2.2.1 Push 队列

```
┌─────────────────────────────────────────────────────────────────────┐
│  Push 队列结构                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  队列来源 (自动收集):                                                 │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 新建/修改:  WHERE syncStatus = 'pending' AND deletedAt IS NULL│    │
│  │ 删除:      WHERE syncStatus = 'pending' AND deletedAt IS NOT NULL│    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  依赖排序:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 批次 1: Scores, Setlists                                     │    │
│  │         ↓ (需要先获得 serverId)                              │    │
│  │ 批次 2: InstrumentScores (含 annotationsJson)               │    │
│  │         ↓ (需要父 Score 的 serverId)                         │    │
│  │ 批次 3: SetlistScores                                        │    │
│  │         (需要 Setlist 和 Score 的 serverId)                  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  跳过规则:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 如果父实体还没有 serverId → 跳过，等待下一轮同步              │    │
│  │ 例: 新 Score + 新 InstrumentScore 同时 pending               │    │
│  │     第一轮只推送 Score                                       │    │
│  │     第二轮推送 InstrumentScore (此时 Score 已有 serverId)    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 Push 数据收集

Push 时通过查询数据库中所有 `syncStatus='pending'` 的记录来收集待同步数据。

**收集步骤：**

1. 查询待同步的新建/修改记录：
   - Scores: `WHERE syncStatus='pending' AND deletedAt IS NULL`
   - InstrumentScores: `WHERE syncStatus='pending' AND deletedAt IS NULL`
   - Setlists: `WHERE syncStatus='pending' AND deletedAt IS NULL`
   - SetlistScores: `WHERE syncStatus='pending' AND deletedAt IS NULL`
   - 注：Annotation 数据嵌入 InstrumentScore.annotationsJson，不单独查询

2. 查询待同步的删除记录：
   - Scores: `WHERE syncStatus='pending' AND deletedAt IS NOT NULL`
   - InstrumentScores: `WHERE syncStatus='pending' AND deletedAt IS NOT NULL`
   - Setlists: `WHERE syncStatus='pending' AND deletedAt IS NOT NULL`
   - SetlistScores: `WHERE syncStatus='pending' AND deletedAt IS NOT NULL`

3. 如果所有查询结果都为空，则无需 Push

**依赖顺序处理：**

子实体依赖父实体的 serverId，因此 Push 时需要处理依赖关系：

| 实体 | 依赖的父实体 | 处理方式 |
|------|-------------|---------|
| Score | 无 | 直接 Push |
| Setlist | 无 | 直接 Push |
| InstrumentScore | Score | 如果父 Score 无 serverId，跳过本次，等待下次同步 |
| SetlistScore | Setlist, Score | 如果父实体无 serverId，跳过本次 |

当存在跳过的子实体时，系统会在下一次同步周期中重试（父实体获得 serverId 后）。

#### 2.2.3 Push 请求格式

**请求端点：** `POST /library/push`

**请求体字段：**

| 字段 | 类型 | 说明 |
|------|------|------|
| clientLibraryVersion | int | 客户端当前版本号 |
| scores | array | Score 实体数组 |
| instrumentScores | array | InstrumentScore 实体数组（含 pdfHash 和 annotationsJson） |
| setlists | array | Setlist 实体数组 |
| setlistScores | array | SetlistScore 实体数组 |
| deletes | array | 待删除的实体标识，格式: `["score:456", "instrumentScore:789"]` |

**每个实体包含：**

| 字段 | 说明 |
|------|------|
| entityType | 实体类型 |
| entityId | 本地 UUID |
| serverId | 服务器 ID（更新时有值，创建时为 null） |
| operation | create / update |
| version | 版本号 |
| data | JSON 格式的业务数据 |
| localUpdatedAt | 本地更新时间 |

#### 2.2.4 Push 响应处理

**200 OK 响应字段：**

| 字段 | 说明 |
|------|------|
| newLibraryVersion | 新的全局版本号 |
| serverIdMapping | UUID → serverId 的映射表 |
| accepted | 成功处理的 UUID 列表 |
| rejected | 被拒绝的 UUID 列表 |

**200 OK 处理步骤：**
1. 保存 serverId 映射到本地实体
2. 更新 syncStatus = 'synced'
3. 更新本地 libraryVersion
4. 物理删除已同步的删除记录（syncStatus='synced' 且 deletedAt 不为空的记录）

**412 Conflict 响应处理：**
1. 跳转到 Pull 阶段
2. 拉取缺失版本的变更
3. 合并数据
4. 使用新的 libraryVersion 重试 Push

### 2.3 Pull 逻辑详解

#### 2.3.1 Pull 请求

**请求端点：** `GET /library/pull?since={version}`

**响应结构：**

```dart
SyncPullResponse {
  libraryVersion: int,            // 最新版本号
  isFullSync: bool,               // 是否全量同步

  scores: List<SyncEntityData>?,        // 包含已删除的（isDeleted=true）
  instrumentScores: List<SyncEntityData>?,  // 含 annotationsJson
  setlists: List<SyncEntityData>?,
  setlistScores: List<SyncEntityData>?,

  deleted: List<String>?,               // ["score:123", "instrumentScore:456", ...]
}

SyncEntityData {
  entityType: String,      // "score", "instrumentScore", etc.
  serverId: int,
  version: int,
  data: String,            // JSON 业务数据（InstrumentScore 含 annotationsJson）
  updatedAt: DateTime,
  isDeleted: bool,         // 标记该实体是否已被删除
}
```

**说明：** 删除信息通过 `SyncEntityData.isDeleted` 字段表示。`deleted` 列表作为冗余字段提供向后兼容，客户端应优先使用 `isDeleted` 字段判断。

**响应字段：**

| 字段 | 说明 |
|------|------|
| libraryVersion | 最新版本号 |
| scores | Score 实体数组（包含 isDeleted=true 的已删除记录） |
| instrumentScores | InstrumentScore 实体数组（含 pdfHash 和 annotationsJson） |
| setlists | Setlist 实体数组 |
| setlistScores | SetlistScore 实体数组 |
| deleted | 已删除实体标识数组（冗余字段），格式: `["score:123", ...]` |

#### 2.3.2 Pull 处理流程

**处理步骤：**

1. 按 version 排序所有实体（确保删除→重建场景的正确顺序）

2. 遍历每个实体（通过 isDeleted 字段判断状态）：
   - 如果 `isDeleted=true` → 同步远程的删除到本地（详见 §2.4.2）
   - 如果本地不存在 → 创建新记录，syncStatus='synced'
   - 如果本地存在 → 调用合并逻辑（详见 §2.4.1）

3. 更新本地 libraryVersion

### 2.4 冲突解决详解

pending 包括修改操作和删除操作，通过 `deletedAt` 字段区分：
- `pending` + `deletedAt IS NULL` = 新建或修改
- `pending` + `deletedAt IS NOT NULL` = 待同步的删除操作

只要本地有未同步的变更（`syncStatus='pending'`），就会覆盖服务器上其他设备的修改。
  
两种表现形式
  | 变体         | 本地状态       | 服务器状态     | 结果               |
  |--------------|----------------|----------------|--------------------|
  | 修改 vs 修改 | pending (deletedAt IS NULL) | 其他设备的修改 | 本地修改覆盖服务器 |
  | 删除 vs 修改 | pending (deletedAt IS NOT NULL) | 其他设备的修改 | 本地删除覆盖服务器 |

#### 2.4.1 Merge 逻辑

```
┌─────────────────────────────────────────────────────────────────────┐
│  Merge 决策树                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  对于每个服务器返回的实体:                                            │
│                                                                      │
│                    ┌─────────────────┐                               │
│                    │ 服务器实体到达   │                               │
│                    └────────┬────────┘                               │
│                             │                                        │
│                             ▼                                        │
│                    ┌─────────────────┐                               │
│                    │ 本地存在记录？   │                               │
│                    └────────┬────────┘                               │
│                     │              │                                 │
│                    YES             NO                                │
│                     │              │                                 │
│                     ▼              ▼                                 │
│            ┌──────────────┐  ┌──────────────────┐                   │
│            │ 检查 syncStatus │  │ 创建新记录        │                   │
│            └───────┬──────┘  │ syncStatus=synced│                   │
│                    │         └──────────────────┘                   │
│         ┌──────────┴─────────┐                                       │
│         │                    │                                       │
│      pending              synced                                     │
│         │                    │                                       │
│         ▼                    ▼                                       │
│  ┌─────────────────┐  ┌─────────────────┐                           │
│  │ 本地优先         │  │ 服务器优先       │                           │
│  │ 跳过，不覆盖     │  │ 用服务器数据更新  │                           │
│  │ hadConflict=true│  │ syncStatus=synced│                           │
│  └─────────────────┘  └─────────────────┘                           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.4.2 删除冲突处理

| 场景 | 条件 | 处理方式 |
|------|------|---------|
| 服务器删除 + 本地已同步 | 服务器返回 isDeleted=true，本地 syncStatus='synced' | 物理删除本地记录 |
| 服务器删除 + 本地有修改 | 服务器返回 isDeleted=true，本地 syncStatus='pending' | **保留 serverId，直接 Push update**。服务器是软删除，会自动恢复（清除 deletedAt） |
| 本地删除 + 服务器有更新 | 本地 deletedAt 不为空且 syncStatus='pending' | 删除优先，Push 时发送删除请求 |

**说明：** 服务器采用软删除机制（设置 deletedAt），记录并未物理删除。当客户端发送 update 请求时，服务器会自动将 deletedAt 设为 null，实现记录恢复。因此不需要断开 serverId 关联重新创建。

### 2.5 本地操作处理

#### 2.5.1 多次修改合并

本地多次修改同一实体不会产生冲突，所有修改会合并为一次 Push：

```
┌─────────────────────────────────────────────────────────────────┐
│  本地多次修改场景                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  T1: 用户修改 Score A 的 title = "曲目1"                         │
│      → 本地更新记录，syncStatus = 'pending'                      │
│                                                                  │
│  T2: 用户再次修改 Score A 的 title = "曲目2"                     │
│      → 同一条记录被覆盖，仍然是 syncStatus = 'pending'           │
│                                                                  │
│  T3: 用户第三次修改 Score A 的 bpm = 120                         │
│      → 同一条记录被更新，仍然是 syncStatus = 'pending'           │
│                                                                  │
│  T4: 触发 Push（防抖 5s 后）                                     │
│      → 只发送一条记录：title="曲目2", bpm=120                    │
│      → 服务器 libraryVersion: 100 → 101（只 +1）                 │
│      → Score A 的 version = 101                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**关键点：**
- 本地数据库中，同一实体只有一条记录
- 多次修改 = 多次 UPDATE 同一条记录
- Push 时只看最终状态，中间过程不保留
- 服务器只收到一次变更，版本号只增加 1

#### 2.5.2 创建实体

**创建 Score 的处理逻辑：**

1. 检查是否有已删除的同名记录（恢复场景）
2. 如果存在已删除记录 → 恢复该记录：清除 deletedAt，设置 syncStatus = 'pending'
3. 否则 → 插入新记录：生成 UUID，syncStatus = 'pending'，serverId = null
4. 触发同步（防抖 5s）

#### 2.5.3 删除实体

删除操作需要正确处理级联关系，确保本地用户删除和 Pull 同步删除使用统一的逻辑。

##### 2.5.3.1 级联删除规则

| 删除的实体 | 级联删除的子实体 | 说明 |
|-----------|-----------------|------|
| Score | InstrumentScores → Annotations, SetlistScores | 删除乐谱时，其所有分谱、标注、曲单关联都要删除 |
| InstrumentScore | Annotations | 删除分谱时，其所有标注都要删除 |
| Setlist | SetlistScores | 删除曲单时，其所有曲目关联都要删除 |
| Annotation | 无 | 无子实体 |
| SetlistScore | 无 | 无子实体 |

##### 2.5.3.2 删除方式

根据触发来源和实体状态，采用不同的删除方式：

| 场景 | 删除方式 | 说明 |
|------|---------|------|
| 本地用户删除 + 有 serverId | 软删除 | 设置 deletedAt + syncStatus='pending'，等待 Push 同步到服务器 |
| 本地用户删除 + 无 serverId | 物理删除 | 从未同步过，直接从数据库删除 |
| Pull 同步删除 + 本地 synced | 物理删除 | 服务器已删除，本地直接删除 |
| Pull 同步删除 + 本地 pending | 保留本地 | 本地有未同步修改，保留本地数据和 serverId，下次 Push 时服务器自动恢复 |

##### 2.5.3.3 统一级联删除函数

为避免级联删除逻辑分散在多处导致遗漏，应实现统一的级联删除函数：

**删除 Score 的完整流程：**
1. 获取该 Score 下所有 InstrumentScores
2. 对每个 InstrumentScore：物理删除其关联的 Annotations
3. 软删除或物理删除所有 InstrumentScores（根据删除方式）
4. 软删除或物理删除所有关联的 SetlistScores
5. 软删除或物理删除 Score 本身
6. 清理本地 PDF 文件：
   - 对每个 InstrumentScore 的 pdfHash，减少引用计数
   - 如果引用计数减为 0，删除本地 PDF 文件

**删除 InstrumentScore 的完整流程：**
1. 物理删除其关联的 Annotations
2. 判断是否有 serverId：
   - 有 serverId → 软删除 InstrumentScore
   - 无 serverId → 物理删除 InstrumentScore
3. 清理本地 PDF 文件：
   - 获取该 InstrumentScore 的 pdfHash
   - 减少该 pdfHash 的引用计数
   - 如果引用计数减为 0，删除本地 PDF 文件

**删除 Setlist 的完整流程：**
1. 软删除或物理删除所有关联的 SetlistScores
2. 软删除或物理删除 Setlist 本身

##### 2.5.3.4 Pull 同步删除的级联处理

**重要：** Pull 时处理服务器删除（isDeleted=true）必须触发级联删除，而不是只删除单个实体。

当收到 Score 的 isDeleted=true 时：
1. 检查本地 syncStatus
2. 如果是 synced → 调用级联物理删除函数，删除 Score 及其所有子实体
3. 如果是 pending → 忽略服务器删除，保留本地数据和 serverId，下次 Push 时服务器自动恢复

当收到 InstrumentScore 的 isDeleted=true 时：
1. 检查本地 syncStatus
2. 如果是 synced → 物理删除 Annotations，然后物理删除 InstrumentScore
3. 如果是 pending → 忽略服务器删除，保留本地数据和 serverId，下次 Push 时服务器自动恢复

##### 2.5.3.5 Annotation 处理

Annotation 采用嵌入方案，作为 InstrumentScore.annotationsJson 字段存储，不作为独立同步实体：

- 删除 InstrumentScore 时，annotationsJson 随之删除，无需额外处理
- 本地 Annotation 表仅作为缓存，可选保留用于快速查询
- 服务器端不存储独立的 Annotation 记录

### 2.6 Annotation 嵌入同步策略

Annotation（标注）采用 **嵌入 InstrumentScore** 方案，不作为独立同步实体。

#### 2.6.1 设计原则

| 原则 | 说明 |
|------|------|
| 嵌入存储 | Annotation 作为 InstrumentScore.annotationsJson 字段存储 |
| 随父同步 | Annotation 变更触发 InstrumentScore 同步，不独立同步 |
| Last-Write-Wins | 冲突在 InstrumentScore 级别处理，整个 annotationsJson 一起覆盖 |
| 本地缓存 | 本地 Annotation 表仅作为缓存，用于快速查询和编辑 |

#### 2.6.2 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│  Annotation 嵌入同步流程                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐      保存时序列化       ┌──────────────────┐   │
│  │ Annotation   │  ──────────────────►  │ InstrumentScore  │   │
│  │ 本地缓存表    │                        │ .annotationsJson │   │
│  │ (无同步字段)  │  ◄──────────────────  │ (TEXT 字段)       │   │
│  └──────────────┘      打开时反序列化      └──────────────────┘   │
│                                                                  │
│  用户编辑 → 更新本地缓存 → 防抖5秒 → 序列化到IS → IS标记pending    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### 2.6.3 annotationsJson 格式

```json
{
  "version": 1,
  "annotations": [
    {
      "id": "uuid",
      "type": "stroke|text|highlight",
      "color": "#FF0000",
      "strokeWidth": 2.0,
      "points": [0.1, 0.2, 0.15, 0.25],
      "textContent": null,
      "posX": null,
      "posY": null,
      "pageNumber": 1
    }
  ]
}
```

#### 2.6.4 同步行为

| 操作 | 本地处理 | 同步效果 |
|------|---------|---------|
| 创建/修改/删除标注 | 更新本地缓存表 → 序列化到 IS.annotationsJson | IS 标记 pending，随 IS 一起同步 |
| Pull 收到 IS 更新 | 反序列化 annotationsJson → 覆盖本地缓存表 | Last-Write-Wins 在 IS 级别 |
| 删除 IS | 本地缓存表关联删除（外键 CASCADE） | 服务器端 annotationsJson 随 IS 删除 |

#### 2.6.5 优化措施

1. **防抖**：用户绘画期间不触发序列化，手指抬起后等待 5 秒再序列化到 IS
2. **版本号稳定**：用户画 10 笔只触发 1 次 IS 更新，而非 10 次 Annotation 更新
3. **批量保存**：多个标注变更合并为一次 IS 更新

---

## 3. PDF 文件同步详解

### 3.1 PDF 存储架构

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF 存储架构 (基于 Hash 的内容寻址 - 全局去重)                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  设计理念:                                                            │
│  • 相同内容的 PDF 在全局只存一份（跨用户去重）                          │
│  • 文件名 = MD5 Hash，与用户无关                                      │
│  • InstrumentScore 通过 pdfHash 引用文件                             │
│  • 上传前检查全局是否已有该 Hash，有则直接引用（秒传）                   │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  客户端本地存储:                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  /documents/pdfs/                                            │    │
│  │  ├── abc123def456.pdf     ← Hash 作为文件名                  │    │
│  │  ├── 789xyz000111.pdf                                        │    │
│  │  └── ...                                                     │    │
│  │                                                              │    │
│  │  InstrumentScore 表:                                         │    │
│  │  ┌────────────────────────────────────────────────────────┐ │    │
│  │  │ id       │ pdfHash          │ pdfPath                  │ │    │
│  │  │ uuid-1   │ abc123def456     │ /documents/pdfs/abc...pdf│ │    │
│  │  │ uuid-2   │ abc123def456     │ /documents/pdfs/abc...pdf│ ← 共享│
│  │  │ uuid-3   │ 789xyz000111     │ /documents/pdfs/789...pdf│ │    │
│  │  └────────────────────────────────────────────────────────┘ │    │
│  │                                                              │    │
│  │  本地引用计数 = COUNT(InstrumentScore WHERE pdfHash = ?)    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  服务器全局存储:                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  /uploads/global/pdfs/           ← 全局目录，不分用户         │    │
│  │  ├── abc123def456.pdf                                        │    │
│  │  ├── 789xyz000111.pdf                                        │    │
│  │  └── ...                                                     │    │
│  │                                                              │    │
│  │  PdfFile 表 (可选，用于管理):                                 │    │
│  │  ┌────────────────────────────────────────────────────────┐ │    │
│  │  │ hash (PK)        │ storagePath              │ size     │ │    │
│  │  │ abc123def456     │ /global/pdfs/abc...pdf   │ 2.5MB    │ │    │
│  │  │ 789xyz000111     │ /global/pdfs/789...pdf   │ 1.2MB    │ │    │
│  │  └────────────────────────────────────────────────────────┘ │    │
│  │                                                              │    │
│  │  全局引用计数:                                                │    │
│  │  SELECT COUNT(*) FROM instrument_scores                      │    │
│  │  WHERE pdf_hash = ? AND deleted_at IS NULL                   │    │
│  │  (跨所有用户统计)                                             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  示例场景:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 用户 A 上传 "贝多芬第九交响曲.pdf" (hash: abc123)             │    │
│  │   → 服务器存储文件，hash=abc123                              │    │
│  │                                                              │    │
│  │ 用户 B 上传相同文件 (hash: abc123)                            │    │
│  │   → 秒传: 服务器已有此 hash，直接引用，无需传输               │    │
│  │   → 用户 B 的 InstrumentScore.pdfHash = abc123               │    │
│  │                                                              │    │
│  │ 用户 A 删除该分谱                                             │    │
│  │   → 检查全局引用计数: 用户 B 还在引用                         │    │
│  │   → PDF 文件保留                                             │    │
│  │                                                              │    │
│  │ 用户 B 也删除该分谱                                           │    │
│  │   → 检查全局引用计数: 0                                       │    │
│  │   → PDF 文件物理删除                                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 PDF 同步状态

InstrumentScore 表中的 `pdfSyncStatus` 字段：

| 状态 | 含义 | 触发条件 |
|------|------|---------|
| `pending` | PDF 待上传 | 本地新增 PDF，尚未上传到服务器 |
| `synced` | PDF 已同步 | 上传成功 或 本地 Hash 与服务器一致 |
| `needsDownload` | 需要下载 | Pull 时发现服务器有新 Hash，本地没有 |

### 3.3 Upload 逻辑详解

#### 3.3.1 Upload 队列

**队列来源查询条件：**
- pdfSyncStatus = 'pending'
- pdfHash IS NOT NULL（已计算 hash）
- pdfPath IS NOT NULL（有本地文件）

**说明：** PDF 通过 hash 上传到全局存储，不依赖 InstrumentScore 的 serverId。元数据和 PDF 可以独立上传，服务器通过 pdfHash 字段关联。

**处理顺序：** 串行处理，避免占用过多带宽

**优先级（可选）：**
1. 用户正在查看的分谱
2. 最近创建的
3. 其他

#### 3.3.2 Upload 流程

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF Upload 流程                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────┐                                                 │
│  │ 1. 读取本地 PDF  │                                                 │
│  └────────┬────────┘                                                 │
│           │                                                          │
│           ▼                                                          │
│  ┌─────────────────────┐                                             │
│  │ 2. 计算 MD5 Hash    │                                             │
│  │    hash = md5(bytes)│                                             │
│  └────────┬────────────┘                                             │
│           │                                                          │
│           ▼                                                          │
│  ┌────────────────────────────────────┐                              │
│  │ 3. 秒传检测                         │                              │
│  │    GET /file/checkHash?hash=abc123 │                              │
│  └────────┬────────────────┬──────────┘                              │
│           │                │                                         │
│        存在              不存在                                       │
│           │                │                                         │
│           ▼                ▼                                         │
│  ┌─────────────┐  ┌──────────────────────┐                          │
│  │ 4a. 秒传成功 │  │ 4b. 上传文件          │                          │
│  │ 跳过上传    │  │ POST /file/upload     │                          │
│  └──────┬──────┘  └──────────┬───────────┘                          │
│         │                    │                                       │
│         └────────────────────┘                                       │
│                    │                                                 │
│                    ▼                                                 │
│  ┌─────────────────────────────────────────┐                        │
│  │ 5. 更新本地数据库                         │                        │
│  │    pdfSyncStatus = 'synced'             │                        │
│  │    pdfHash = 'abc123'                   │                        │
│  └─────────────────────────────────────────┘                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.3.3 秒传机制（全局去重）

**上传 PDF 的处理逻辑：**

1. 读取本地 PDF 文件内容
2. 计算 MD5 Hash
3. 调用 `GET /file/checkHash?hash={hash}` 检查服务器全局是否已有此 Hash（跨所有用户）
4. 如果存在：
   - 秒传成功，无需上传文件
   - 调用 API 将 InstrumentScore 的 pdfHash 指向该文件
5. 如果不存在：
   - 首次上传该文件到全局存储
   - 调用 `POST /file/upload` 上传文件
6. 更新本地 pdfSyncStatus = 'synced'，pdfHash = 计算的 hash 值

**服务器端 checkHash 实现方式：**
- 方案 1：查询 PdfFile 表是否存在该 hash
- 方案 2：直接检查文件系统 `/uploads/global/pdfs/{hash}.pdf` 是否存在

### 3.4 Download 逻辑详解

#### 3.4.1 Download 队列

**队列来源查询条件：**
- pdfSyncStatus = 'needsDownload'

**触发时机：**
1. Pull 时发现新的 pdfHash
2. 用户打开分谱时（按需下载）
3. 后台批量下载（可选，WiFi 环境）

**优先级：**
1. 用户正在请求查看的 → 立即下载，显示进度
2. 后台队列 → 串行下载

#### 3.4.2 Download 流程

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF Download 流程                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌───────────────────────┐                                           │
│  │ 1. 检查本地是否已有    │                                           │
│  │    Hash 对应的文件     │                                           │
│  └───────────┬───────────┘                                           │
│              │                                                       │
│       ┌──────┴──────┐                                                │
│       │             │                                                │
│    已存在         不存在                                              │
│       │             │                                                │
│       ▼             ▼                                                │
│  ┌─────────┐  ┌─────────────────────────┐                           │
│  │ 复用文件 │  │ 2. 从服务器下载          │                           │
│  │ 更新路径 │  │ GET /file/download/{hash}│                           │
│  └────┬────┘  └───────────┬─────────────┘                           │
│       │                   │                                          │
│       │                   ▼                                          │
│       │           ┌───────────────────────┐                         │
│       │           │ 3. 验证 Hash           │                         │
│       │           │ if md5(bytes) != hash │                         │
│       │           │   throw CorruptError   │                         │
│       │           └───────────┬───────────┘                         │
│       │                       │                                      │
│       │                       ▼                                      │
│       │           ┌─────────────────────────────┐                   │
│       │           │ 4. 保存到本地                │                   │
│       │           │ path = /pdfs/{hash}.pdf     │                   │
│       │           └───────────┬─────────────────┘                   │
│       │                       │                                      │
│       └───────────────────────┤                                      │
│                               ▼                                      │
│               ┌─────────────────────────────────────┐               │
│               │ 5. 更新数据库                        │               │
│               │    pdfPath = '/pdfs/{hash}.pdf'     │               │
│               │    pdfSyncStatus = 'synced'         │               │
│               └─────────────────────────────────────┘               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.4.3 按需下载 (懒加载)

**用户打开分谱时的处理逻辑：**

1. 检查本地文件是否存在且 Hash 匹配
   - 如果匹配 → 直接使用本地文件

2. 检查是否有其他 InstrumentScore 已下载了相同 Hash 的文件
   - 如果存在 → 复用已下载的文件，更新当前记录的 pdfPath

3. 如果以上都不满足 → 从服务器下载

### 3.5 引用计数与删除

#### 3.5.1 引用计数逻辑（全局）

```
┌─────────────────────────────────────────────────────────────────────┐
│  PDF 引用计数 (全局跨用户)                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  全局引用计数 = 所有用户中使用相同 pdfHash 的 InstrumentScore 数量     │
│                                                                      │
│  服务器端查询:                                                        │
│  SELECT COUNT(*) FROM instrument_scores                              │
│  WHERE pdf_hash = 'abc123'                                           │
│    AND deleted_at IS NULL                                            │
│  -- 注意: 不限制 user_id，跨所有用户统计                              │
│                                                                      │
│  客户端本地查询 (只统计本地):                                         │
│  SELECT COUNT(*) FROM instrument_scores                              │
│  WHERE pdfHash = 'abc123'                                            │
│    AND deletedAt IS NULL                                             │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  示例 (跨用户场景):                                                   │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ pdfHash = 'abc123' (贝多芬第九交响曲.pdf)                       │ │
│  │                                                                 │ │
│  │ 用户 A:                                                         │ │
│  │   InstrumentScore A1 (Piano)  ──┐                               │ │
│  │   InstrumentScore A2 (Violin) ──┤                               │ │
│  │                                  │                               │ │
│  │ 用户 B:                          ├─→ 全局引用计数 = 4            │ │
│  │   InstrumentScore B1 (Full)   ──┤                               │ │
│  │                                  │                               │ │
│  │ 用户 C:                          │                               │ │
│  │   InstrumentScore C1 (Cello)  ──┘                               │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  用户 A 删除 A1 和 A2:                                               │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ 全局引用计数 4 → 2 (用户 B 和 C 还在引用)                        │ │
│  │ 服务器 PDF 文件保留                                             │ │
│  │ 用户 A 本地：引用计数 0，删除本地 PDF 副本                       │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  所有用户都删除后:                                                    │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │ 全局引用计数 → 0                                                │ │
│  │ 服务器物理删除 /global/pdfs/abc123.pdf                          │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3.5.2 客户端删除流程

**删除 InstrumentScore 时的 PDF 处理逻辑：**

1. 获取要删除的 InstrumentScore 的 pdfHash
2. 计算删除后的本地引用计数（排除当前记录，排除已删除的记录）
3. 如果本地引用计数 = 0 → 删除本地 PDF 文件
4. 服务器端会单独处理全局引用计数

#### 3.5.3 服务器端删除逻辑（全局引用计数）

**当收到删除 InstrumentScore 的请求时：**

1. 获取要删除的 InstrumentScore 的 pdfHash
2. 计算全局引用计数（跨所有用户）：
   - 查询条件：pdf_hash = ? AND id != ? AND deleted_at IS NULL
   - 注意：不限制 user_id
3. 如果 count = 0：
   - 没有任何用户在引用该 PDF
   - 物理删除文件：`/uploads/global/pdfs/{hash}.pdf`
   - 删除 PdfFile 表记录（如果有）
4. 如果 count > 0：
   - 还有其他用户（或本用户其他分谱）在引用
   - 保留 PDF 文件，只删除 InstrumentScore 记录

### 3.6 冲突处理

| 场景 | 条件 | 处理方式 |
|------|------|---------|
| 本地和服务器的 pdfHash 不同 | 本地 pdfSyncStatus = 'pending' | **本地优先**：保留本地 pdfHash，上传本地 PDF，服务器更新 pdfHash |
| 本地已同步，服务器更新了 pdfHash | 本地 pdfSyncStatus = 'synced' | **服务器优先**：更新本地 pdfHash，设置 pdfSyncStatus = 'needsDownload'，下载新 PDF，检查旧 Hash 引用计数 |
| 相同 Hash | 内容相同 | **无冲突**：相同 Hash 意味着相同内容 |

### 3.7 UI 状态显示

```
┌─────────────────────────────────────────────────────────────────────┐
│  Settings → Cloud Sync 页面显示                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  同步状态:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ ☁️ Cloud Sync                                                │    │
│  │                                                              │    │
│  │ 元数据: ✓ 已同步 (version 105)                               │    │
│  │ 上次同步: 2 分钟前                                           │    │
│  │                                                              │    │
│  │ PDF 文件:                                                    │    │
│  │ ├─ 待上传: 3 个文件 (15.2 MB)                                │    │
│  │ ├─ 待下载: 1 个文件 (2.1 MB)                                 │    │
│  │ └─ 正在上传: Symphony_No5.pdf (45%)                          │    │
│  │                                                              │    │
│  │ [立即同步]                                                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  存储使用:                                                            │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 本地: 256 MB                                                 │    │
│  │ 云端: 245 MB (已去重)                                        │    │
│  │ 配额: 1 GB                                                   │    │
│  │ ████████░░░░░░░░░░░░ 24.5%                                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 附录

### A. 同步服务函数架构

#### A.1 触发层（极简设计）

```
SyncTriggerService
    │
    ├──► requestSync(immediate: false)    ← 所有数据变更调用
    │        │
    │        └──► 5 秒防抖 → _performSync()
    │
    ├──► requestSync(immediate: true)     ← 网络恢复时调用
    │        │
    │        └──► 立即 → _performSync()
    │
    └──► 网络状态监听
             │
             ├──► 无网络 → _hasNetwork = false (暂停)
             │
             └──► 有网络 → _hasNetwork = true + requestSync(immediate: true)
```

#### A.2 整体调用结构

```
_performSync()
    │
    ├──► _pushLocalChanges()
    │        │
    │        ├──► 收集待同步数据
    │        │        ├──► _getPendingScores()
    │        │        ├──► _getPendingInstrumentScores()  // 含 annotationsJson
    │        │        ├──► _getPendingSetlists()
    │        │        └──► _getPendingSetlistScores()
    │        │
    │        ├──► 收集待删除数据
    │        │        ├──► _getDeletedScores()
    │        │        ├──► _getDeletedInstrumentScores()
    │        │        ├──► _getDeletedSetlists()
    │        │        └──► _getDeletedSetlistScores()
    │        │
    │        ├──► 构建请求体（按依赖顺序）
    │        │
    │        ├──► 发送 Push 请求
    │        │
    │        └──► 处理响应
    │                 ├──► 更新 serverId 映射
    │                 ├──► 标记 syncStatus='synced'
    │                 └──► 物理删除已同步的删除记录
    │
    ├──► _pullRemoteChanges()
    │        │
    │        ├──► 获取远程变更
    │        │
    │        ├──► 按 version 排序
    │        │
    │        ├──► 合并变更（按依赖顺序）
    │        │        ├──► _mergeScore()
    │        │        ├──► _mergeInstrumentScore()  // 含 annotationsJson 反序列化
    │        │        ├──► _mergeSetlist()
    │        │        └──► _mergeSetlistScore()
    │        │
    │        ├──► 处理删除列表
    │        │        └──► _processRemoteDelete()
    │        │
    │        └──► 更新本地 libraryVersion
    │
    └──► _syncPendingPdfs()
             ├──► 上传待上传的 PDF
             └──► 下载待下载的 PDF
```

#### A.2 Merge 函数通用逻辑

每个 `_merge{Entity}()` 函数遵循相同的处理模式：

```
_mergeEntity(serverData)
    │
    ├──► 查找本地记录（通过 serverId）
    │
    ├──► if serverData.isDeleted == true
    │        │
    │        ├──► if 本地存在 && syncStatus == 'pending'
    │        │        └──► 保留本地，保留 serverId（本地优先，下次 Push 时服务器恢复）
    │        │
    │        └──► if 本地存在 && syncStatus == 'synced'
    │                 └──► 调用级联删除函数（物理删除）
    │
    ├──► if 本地不存在
    │        └──► 创建新记录，syncStatus = 'synced'
    │
    └──► if 本地存在
             │
             ├──► if syncStatus == 'pending'
             │        └──► 保留本地修改（本地优先）
             │
             └──► if syncStatus == 'synced'
                      └──► 用服务器数据覆盖本地
```

#### A.3 级联删除函数调用关系

级联删除函数被多处调用，需要统一实现以避免遗漏：

```
调用来源
    │
    ├──► DatabaseService.deleteScore()           （用户本地删除）
    │        └──► cascadeDeleteScore(id, soft: true)
    │
    ├──► DatabaseService.deleteInstrumentScore() （用户本地删除）
    │        └──► cascadeDeleteInstrumentScore(id, soft: true)
    │
    ├──► DatabaseService.deleteSetlist()         （用户本地删除）
    │        └──► cascadeDeleteSetlist(id, soft: true)
    │
    ├──► LibrarySyncService._mergeScore()        （Pull 同步删除）
    │        └──► cascadeDeleteScore(id, soft: false)
    │
    ├──► LibrarySyncService._mergeInstrumentScore()
    │        └──► cascadeDeleteInstrumentScore(id, soft: false)
    │
    └──► LibrarySyncService._processRemoteDelete()
             └──► cascadeDelete{Entity}(id, soft: false)
```

**级联删除函数内部逻辑：**

```
cascadeDeleteScore(scoreId, soft)
    │
    ├──► 获取所有关联的 InstrumentScores
    │
    ├──► for each InstrumentScore:
    │        ├──► 物理删除关联的 Annotations
    │        └──► soft ? 软删除 : 物理删除 InstrumentScore
    │
    ├──► soft ? 软删除 : 物理删除 关联的 SetlistScores
    │
    └──► soft ? 软删除 : 物理删除 Score 本身


cascadeDeleteInstrumentScore(instrumentScoreId, soft)
    │
    ├──► 物理删除关联的 Annotations
    │
    └──► soft ? 软删除 : 物理删除 InstrumentScore


cascadeDeleteSetlist(setlistId, soft)
    │
    ├──► soft ? 软删除 : 物理删除 关联的 SetlistScores
    │
    └──► soft ? 软删除 : 物理删除 Setlist 本身
```

#### A.4 函数参数说明

| 参数 | 说明 |
|------|------|
| `soft: true` | 软删除：设置 deletedAt + syncStatus='pending'，用于用户本地删除已同步实体 |
| `soft: false` | 物理删除：从数据库中删除记录，用于 Pull 同步删除或删除从未同步的实体 |

### B. 版本号机制详解

#### B.1 版本号递增时机

版本号采用 **Per-Entity Version** 策略：每个实体变更都会递增 libraryVersion。

**Push 4 个实体时的版本变化示例：**
```
libraryVersion: 100 → 104
score1.version = 101
score2.version = 102
instrumentScore1.version = 103  // 含 annotationsJson
instrumentScore2.version = 104
```

**Pull(since=100) 时：** 返回所有 version > 100 的实体。

**Annotation 对版本号的影响（嵌入方案）：**

Annotation 采用嵌入方案后，标注变更不再独立递增 `libraryVersion`，而是随 InstrumentScore 一起递增：
- 用户画 10 笔标注 → 触发 1 次 InstrumentScore 更新 → `libraryVersion` 只增加 1
- 大幅减少版本号增长速度，避免因频繁标注导致的版本膨胀

优化措施：
- **防抖 5 秒**：用户绘画期间不触发序列化，手指抬起后等待 5 秒
- **批量保存**：多个标注变更合并为一次 InstrumentScore 更新
- **64 位整数**：即使每秒递增 1000 次，也需要约 2.9 亿年才会溢出

#### B.2 版本号类型

| 层            | 类型    | 范围                      | 说明        |
|---------------|---------|---------------------------|-------------|
| Dart (移动端) | int     | 64 位有符号 ≈ ±9.2 × 10¹⁸ | 永远够用   |
| Dart (Web)    | int     | 53 位精度 ≈ ±9 × 10¹⁵     | 够用       |
| SQLite        | INTEGER | 64 位有符号               | 够用       |
| PostgreSQL    | bigint  | 64 位                     | 够用       |

#### B.3 版本号语义

- `libraryVersion`: 全局版本号，表示用户库的整体状态
- `entity.version`: 该实体最后一次变更时的库版本号
- Pull 时通过比较实体的 version 与本地的 libraryVersion 来判断是否需要同步该实体

### C. 错误处理策略

| 错误类型 | 处理方式 |
|---------|---------|
| 网络超时 | 重试 3 次，指数退避 (5s, 15s, 45s) |
| 401 Unauthorized | 跳转登录页面 |
| 412 Conflict | Pull → Merge → 重试 Push |
| 413 Payload Too Large | 提示用户 PDF 文件过大 |
| 500 Server Error | 30 秒后重试 |
| PDF 下载失败 | 保持 needsDownload 状态，下次重试 |
| PDF Hash 不匹配 | 重新下载 |

### D. 性能优化

1. **批量操作**: Push/Pull 使用批量 API，减少请求次数
2. **防抖**: 本地操作后 5 秒内的变更合并为一次同步
3. **串行 PDF**: PDF 上传/下载串行执行，避免带宽竞争
4. **按需加载**: Annotations 和 PDF 按需加载，首次同步快
5. **Hash 去重**: 相同内容只存一份，节省存储和带宽

### E. 日志记录

关键操作日志格式：

| 阶段 | 日志示例 |
|------|---------|
| 同步开始 | `[LibrarySyncService] === SYNC START ===` |
| Push | `[LibrarySyncService] Push: scores=2, instrumentScores=1, deletes=0` |
| Pull | `[LibrarySyncService] Pull: pulled=5, conflicts=1` |
| PDF 同步 | `[LibrarySyncService] PDF: uploaded=1, downloaded=0, skipped(秒传)=1` |
| 同步完成 | `[LibrarySyncService] === SYNC COMPLETE: 1523ms ===` |
